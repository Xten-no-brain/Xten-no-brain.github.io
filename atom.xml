<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xten&#39;s Blog</title>
  
  
  <link href="https://xten-no-brain.github.io/atom.xml" rel="self"/>
  
  <link href="https://xten-no-brain.github.io/"/>
  <updated>2025-05-06T21:24:16.022Z</updated>
  <id>https://xten-no-brain.github.io/</id>
  
  <author>
    <name>Xten</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>网络</title>
    <link href="https://xten-no-brain.github.io/2025/04/27/%E7%BD%91%E7%BB%9C/"/>
    <id>https://xten-no-brain.github.io/2025/04/27/%E7%BD%91%E7%BB%9C/</id>
    <published>2025-04-27T14:49:19.000Z</published>
    <updated>2025-05-06T21:24:16.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;网络模型&quot;&gt;&lt;a href=&quot;#网络模型&quot; class=&quot;headerlink&quot; title=&quot;网络模型&quot;&gt;&lt;/a&gt;网络模型&lt;/h1&gt;&lt;h1 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="网络" scheme="https://xten-no-brain.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机基础" scheme="https://xten-no-brain.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>操作系统</title>
    <link href="https://xten-no-brain.github.io/2025/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <id>https://xten-no-brain.github.io/2025/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</id>
    <published>2025-04-27T14:49:12.000Z</published>
    <updated>2025-05-01T13:43:39.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h1 id="系统内核"><a href="#系统内核" class="headerlink" title="系统内核"></a>系统内核</h1><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;硬件&quot;&gt;&lt;a href=&quot;#硬件&quot; class=&quot;headerlink&quot; title=&quot;硬件&quot;&gt;&lt;/a&gt;硬件&lt;/h1&gt;&lt;h1 id=&quot;系统内核&quot;&gt;&lt;a href=&quot;#系统内核&quot; class=&quot;headerlink&quot; title=&quot;系统内核&quot;&gt;&lt;/a&gt;系统内核&lt;/h</summary>
      
    
    
    
    <category term="操作系统" scheme="https://xten-no-brain.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="计算机基础" scheme="https://xten-no-brain.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="https://xten-no-brain.github.io/2025/04/27/Redis/"/>
    <id>https://xten-no-brain.github.io/2025/04/27/Redis/</id>
    <published>2025-04-27T13:59:44.000Z</published>
    <updated>2025-05-18T12:06:00.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">由于项目中只用到了 Hash 结构，先对其进行详细记录，其余数据结构后续补充</span><br></pre></td></tr></table></figure><h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>宕机或服务器重启后，恢复 Redis 缓存中的数据</p><p><strong>如何实现？</strong></p><p>当 Redis 写操作执行成功后，将其追加到 AOF 日志中，该文件位于磁盘中，可以实现持久化存储</p><p><strong>读操作是否需要存储？</strong></p><p>不需要，读操作不会改变数据状态，没有记录的必要</p><p><strong>为什么要在写操作执行成功后才追加？</strong></p><ol><li>保证 AOF 中记录的语法都是正确的，避免语法检查这一不必要的开销</li><li>避免当前写操作的执行被阻塞，保证 Redis 性能</li></ol><h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><ol><li>将 Redis 命令 追加到 AOF 这一操作，会阻塞主进程执行下一个 Redis 命令</li><li>由于写操作执行成功后才做追加，如果此时服务器挂了，还是会造成数据丢失</li></ol><h3 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h3><p>Redis 提供了三种写回硬盘的策略</p><ol><li>Always，每条写操作执行成功后，立即将 AOF 日志写回硬盘</li><li>Everysec，写操作执行成功后，先将其加入 AOF 缓冲区，每隔一秒将缓冲区的内容写回硬盘</li><li>No，写操作执行成功后，将其加入 AOF 缓冲区，由操作系统决定何时写回硬盘</li></ol><p><strong>这三种策略是如何实现的？</strong></p><p>本质上是 fsync() 函数的调用时机不同</p><p>Always 每次写入 AOF 数据后，立即调用 fsync() 函数</p><p>Everysec 创建一个异步任务来调用 fsync() 函数</p><p>No 永不调用 fsync() 函数</p><p><strong>如何选取？</strong></p><p>上述风险中提到的两个点，本质上是互斥的，无法同时兼顾</p><p>具体的写回策略须根据业务需要进行设置，给出参考</p><ol><li>追求高性能，采用 No 策略</li><li>追求高可靠，采用 Always 策略，尽可能减少数据丢失</li><li>追求性能且允许少量数据丢失，采取折中的 Everysec 策略</li></ol><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><p>随着执行的写操作命令越来越多，AOF 文件的大小越来越大</p><p>重启 Redis 后，需要读 AOF 文件恢复缓存数据，若 AOF 文件太大，恢复过程就很慢</p><p>重写机制就是为了避免这一情况的出现</p><p><strong>如何实现？</strong></p><p>Redis 以 Key-Value 形式存储数据，对于每个 Key，只保留其最新的 Value，这样即使这个键值对被修改多次，也只会保留最新状态，并在 AOF 文件中用一条命令记录它，降低 AOF 文件大小</p><p><strong>具体过程？</strong></p><p>先创建一个新的 AOF 文件，在其中进行重写，重写成功后再覆盖旧的 AOF 文件</p><p><strong>为什么不直接覆写在旧 AOF 文件？</strong></p><p>先写到新的 AOF 中，失败的话，直接删除这个文件即可，避免因重写失败污染AOF 文件</p><p><strong>何时触发？</strong></p><ol><li><p>AOF 文件当前大小 &gt;&#x3D;  auto-aof-rewrite-min-size（ 默认64MB）</p></li><li><p>AOF 文件当前大小 &gt;&#x3D; M * (1 + auto-aof-rewrite-percentage%)，其中 M 为上次重写后 AOF 文件的大小</p><p>举例：上次重写后 AOF 文件大小为 50MB，百分比设定为100，则当前大小达到 100MB 时触发重写</p></li></ol><h3 id="后台重写"><a href="#后台重写" class="headerlink" title="后台重写"></a>后台重写</h3><p>由于此时的 AOF 文件已经很大了，且需要读取所有的键值对，此操作如果在主进程进行，就会阻碍其它命令的操作</p><p><strong>如何进行？</strong></p><p>fork 一个 bgrewriteaof 子进程在后台完成重写</p><p><strong>为什么不用更节省资源的线程？</strong></p><p>多线程之间共享内存，如果修改共享内存中的数据，就要加锁保证线程安全，造成额外开销，降低性能</p><p><strong>子进程如何访问父进程的数据？</strong></p><p>创建子进程时会复制一份父进程的页表，二者可以通过不同的虚拟内存访问相同的物理内存，节约物理内存资源。复制页表的过程会阻塞父进程，页表越大，阻塞时间越长。页表会将物理内存的权限标记为<strong>只读</strong></p><p><strong>写时复制（COW）</strong></p><p>由于物理内存权限被标记为只读，若期间子进程或父进程对该物理内存的数据进行修改，就会触发 Copy On Write 机制</p><p>具体流程为：由于违反系统权限，CPU触发<strong>写保护中断</strong>，操作系统在写保护中断处理函数中进行<strong>物理内存复制</strong>，修改子父进程的<strong>内存读写权限</strong>为可读写，最后再对内存中的数据进行写操作</p><p><strong>COW 机制的作用？</strong></p><p>发生写操作时，才复制物理内存，可以减短复制页表时对主进程的阻塞时长</p><p><strong>如果在重写过程中，主进程修改了已存在的键值对，子父进程的数据一致性如何保证？</strong></p><p>Redis内置了 AOF 重写缓冲区，其在创建 bgrewriteaof 子进程后启用。重写期间，Redis 执行完的写操作会被同步写到 AOF 缓冲区和 AOF 重写缓冲区</p><p>重写期间，主进程执行三个工作：</p><ol><li>执行客户端发送到命令</li><li>将执行后的写操作追加到 AOF 缓冲区</li><li>将执行后的写操作追加到 AOF 重写缓冲区</li></ol><p>当子进程完成 AOF 重写后，会发送一个信号给主进程，主进程接收到信号后，调用信号处理函数，此函数的功能</p><ol><li>将 AOF 重写缓冲区的所有内容追加到新的 AOF 文件中，保证新旧 AOF 文件保持的数据库状态一致</li><li>将新的 AOF 文件改名，覆盖旧的 AOF 文件</li></ol><p><strong>阻塞主进程的操作</strong></p><ol><li>创建子进程时的页表复制过程</li><li>写时复制</li><li>调用信号处理函数</li></ol><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>除 AOF 日志外，Redis还提供了 RDB 快照作为持久化方案</p><p><strong>二者区别</strong></p><ul><li>AOF 文件的内容为操作命令</li><li>RDB 文件的内容为二进制数据</li></ul><p>快照，顾名思义为某一个瞬间的记录。RDB 快照记录的是某一瞬间的内存数据（实际数据）；AOF 文件记录的是命令操作的日志（非实际数据）</p><p>用 RDB 文件恢复数据时，只需将其读入内存中即可；而使用用 AOF 文件时，Redis 会创建一个无网络连接的伪客户端，专门用于执行 AOF 文件中的命令。因此 RDB 恢复效率更高</p><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>Least Recently Used，即淘汰<strong>最近最少使用</strong>的数据</p><p><strong>如何实现？</strong></p><p><strong>传统 LRU</strong></p><p>基于链表，链表中的元素按照操作顺序从前往后排列，最新操作的<strong>键</strong>会被移到头部，触发内存淘汰时，删除尾部元素即可</p><p><strong><span style="color:blue">存在问题：</span></strong></p><ul><li>需要引入链表，额外内存开销</li><li>大量数据访问时，引起很多链表移动操作，耗时太久，降低 Redis 性能</li></ul><p><strong>Redis 中是如何实现的？</strong></p><p>在 Redis 的<strong>对象结构体</strong>中加入<strong>记录最后一次访问时间的额外字段</strong></p><p>内存淘汰时，进行<strong>随机采样</strong>淘汰，随机取 5 个值（可调整），淘汰其中最久没有使用的那个</p><p><strong>缓存污染</strong></p><p>应用一次读取了大量数据，但这些数据只被读取这一次，也会将其保存在 Redis 中很长时间</p><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>Least Frequently Used，即淘汰<strong>最不经常使用</strong>数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">项目用的是LRU，后续补充</span><br></pre></td></tr></table></figure><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">具体复制流程待补充</span><br></pre></td></tr></table></figure><p><strong>主节点</strong>进行读写，发生写操作时自动将其同步给从节点</p><p><strong>从节点</strong>一般只读，并执行主节点同步过来的写操作命令</p><p><strong>主从复制模式</strong></p><ul><li><p><strong><span style="color:blue">全量复制</span></strong></p><p>主从第一次同步时，采用全量复制，此时需要<strong>生成 RDB</strong> 和<strong>传输 RDB</strong>，为避免过多主节点和从节点进行 全量复制，将一部分从节点升级为<strong>经理</strong>，让其也有从节点，进而分担主节点的压力</p><p>同步完成后，主从节点会维持长连接，当主节点接收到写操作命令后，就通过长连接传播给从节点，保证主从节点的数据一致性</p></li><li><p><strong><span style="color:blue">基于长连接的命令传播</span></strong></p></li><li><p><strong><span style="color:blue">增量复制</span></strong></p><p>若主从之间网络断开又恢复正常，就只将断联期间的写操作命令同步给从节点</p></li></ul><p><strong>如何判断节点是否正常工作？</strong></p><p>心跳检测：通过 <strong>ping</strong> 操作，若一半以上的节点去 <strong>ping</strong> 同一个节点，都未收到 <strong>pong</strong> 回应，集群就认为该节点挂了，断开它的连接</p><p><strong>主从模式下，过期 key 如何处理？</strong></p><p>当主节点处理了一个 key 或淘汰算法淘汰了一个 key，主节点就模拟一条 <strong>del 命令</strong>发送个从节点，从节点收到后就执行删除 key 操作</p><p><strong>复制是同步还是异步？</strong></p><p>主节点接收到写命令后，先写到内部缓冲区，然后<strong>异步</strong>发送给从节点</p><h2 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="哨兵节点"></a>哨兵节点</h2><p>哨兵用于实现<strong>主从节点故障转移</strong>，其会监测主节点是否存活，如果发现主节点挂了，就选举一个从节点作新的主节点，并将新主节点的信息通知给从节点和客户端</p><p>哨兵一般以集群方式部署，至少需要 3 个哨兵节点，哨兵集群负责<strong>监控、选主、通知</strong></p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>对数据进行切片，实现 Redis 的<strong>分布式存储</strong></p><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h2><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><p>大量缓存数据在同时过期或者Redis宕机，如果此时有大量用户请求，将同时访问数据库，导致数据库压力突增，可能造成数据库宕机，进而导致系统崩溃</p><p>解决方案：</p><ul><li><p><strong>大量数据同时过期</strong></p><ul><li><p><strong><span style="color:blue">均匀设置过期时间</span></strong></p><p>设置过期时间时加上一个随机数，保证数据不会在同一时间过期</p></li><li><p><strong><span style="color:blue">互斥锁</span></strong></p><p>如果请求访问的数据不在 Redis 中，则加互斥锁，保证同一时间内只有一个请求用于构建缓存，缓存构建完成后，释放锁；未能获取互斥锁的请求，可以等待锁释放后读缓存，也可以直接返回空值或默认值</p><p>互斥锁最好设置<strong>超时时间</strong>，否则加锁的请求如果意外阻塞，就会导致锁不释放且其它请求也拿不到锁，系统出现<strong>无响应现象</strong></p><hr></li><li><p><strong><span style="color:blue">后台更新缓存</span></strong></p><p>后台线程定时更新缓存，保证缓存永久有效</p><ul><li>后台线程频繁检测缓存是否有效，若失效则读数据库更新缓存</li><li>引入 MQ 让其发送消息告知后台更新缓存</li></ul><p>上线前先把数据缓存起来，而非用户访问时才触发缓存构建，此为<strong>缓存预热</strong></p></li></ul></li><li><p><strong>Redis宕机</strong>：</p><ul><li><p><strong><span style="color:blue">服务熔断</span></strong></p><p>启动服务熔断机制，暂停业务层面对缓存的访问，直接<strong>返回错误</strong>，无需访问数据库，降低数据库压力，Redis 恢复后，再允许业务层面访问缓存</p><p>保证数据库正常运行，但业务都无法正常进行</p></li><li><p><strong><span style="color:blue">请求限流机制</span></strong></p><p>允许少量请求到达数据库，剩余请求在入口处就拒绝服务，等 Redis 恢复正常并将<strong>缓存预热</strong>后，再接除限流机制</p></li><li><p><strong><span style="color:blue">高可靠集群</span></strong></p><p>通过<strong>主从节点</strong>方式构建 Redis 集群，当主节点宕机时，从节点切换为主节点，继续提供缓存服务</p></li></ul></li></ul><h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h3><p>某个热点数据在缓存中过期了，此时大量请求访问这个数据，导致这些请求都击穿缓存直接访问数据库，可能使数据库过载</p><p>解决方案：</p><ul><li><p><strong>互斥锁</strong></p><p>保证同一时间只有一个业务线程更新缓存，未能获取锁的请求，要么等待锁释放后重新读取缓存，</p><p>要么返回空值或默认值</p></li><li><p><strong>不设置过期时间</strong></p><p>后台异步更新缓存；或在热点数据将过期前，通知线程更新缓存并重设过期时间</p></li></ul><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><p>查询一个根本不存在的数据，导致每次查询都要去数据库查询，从而使得缓存形同虚设</p><p>解决方案：</p><ul><li><p>非法请求</p><p>入口处判断请求参数是否合法，若非法直接返回错误</p></li><li><p>缓存空值或默认值</p><p>针对查询的数据，在缓存中设置一个空值或默认值，后续查询就不需要查询数据库</p></li><li><p>使用布隆过滤器</p><p>数据库写入时，用布隆过滤器做标记。当请求到来时，若业务线程确认缓存失效，先通过布隆过滤器判断数据是否存在，不存在就不查数据库</p></li></ul><p><strong>布隆过滤器的工作原理</strong></p><p>核心思想：用<strong>一组位数组</strong> + <strong>多个哈希函数</strong>表示集合</p><p>工作原理：</p><ol><li><strong>初始化</strong><ul><li>创建一个长度为 m 的位数组，所有位初始化位 0</li><li>选择 k 个独立的哈希函数，分别映射输入到[0, m - 1]范围</li></ul></li><li><strong>添加元素 x</strong><ul><li>依次使用 k 个哈希函数处理元素 x，得到 k 个下标值</li><li>将这 k 个位置的 bit 设为 1</li></ul></li><li><strong>查询元素 y 是否存在</strong><ul><li>同样计算出 k 个下标值</li><li>若其中任何一个下标的 bit 为 0，则 y 一定不在集合中**（无假阴性）**</li><li>若对应位都为 1，说明 y 可能在集合中**（假阳性）**</li></ul></li></ol><p><strong>m、k 大小如何确定？</strong></p><p>与误判率有关，具体要参考相关的对数计算公式</p><p><strong>为什么会有假阳性？</strong></p><p>因为按<strong>位</strong>判断</p><p>比如说集合中存在 5，就会导致误判 3 和 1也存在集合内</p><p><strong>假阳性能否解决？</strong></p><p>本质为<strong>哈希冲突</strong>，故只能缓解</p><ol><li>加大位数组 m，牺牲一点空间降低假阳性率</li><li>使用层级布隆过滤器</li></ol><p><strong>如何记忆击穿和穿透这两个相近的词？</strong></p><p>将穿透联想成<strong>子弹穿透防弹衣</strong>，即无效防御</p><p>将击穿联想成<strong>大坝的一个缺口</strong>，导致洪水涌入</p><h2 id="数据库与缓存的一致性如何保证"><a href="#数据库与缓存的一致性如何保证" class="headerlink" title="数据库与缓存的一致性如何保证"></a>数据库与缓存的一致性如何保证</h2><p>先更新数据库，再删缓存</p><ul><li><strong><span style="color:blue">写策略步骤</span></strong><ul><li>更新数据库数据</li><li>删除缓存中的数据</li></ul></li><li><strong><span style="color:blue">读策略步骤</span></strong><ul><li>如果读取数据命中缓存，则直接返回数据</li><li>未命中，则先从数据库中读取数据，然后将其写入缓存并返回数据</li></ul></li></ul><p><strong>潜在问题</strong></p><ol><li><p><strong><span style="color:blue">短期数据不一致</span></strong></p><p>发生在数据库更新完成但缓存还未删除的这一时间窗口内</p></li><li><p><strong><span style="color:blue">长期数据不一致</span></strong></p><p>缓存删除失败（网络故障、Redis 服务异常），保留旧数据直到下次删除</p><p>解决方案：</p><ul><li>引入自动重试机制</li><li>设置 TTL 兜底</li></ul></li><li><p><strong><span style="color:blue">主从延迟放大</span></strong></p><p>读写分离下，若删除缓存后立即有查询请求，可能因主从同步延迟导致缓存回填旧数据</p><p>解决方案：</p><ul><li>关键数据强制读主节点</li><li>延迟双删，更新数据库后，延迟一定时间（如主从同步时间 + 缓冲）再次删除缓存</li></ul><p><strong>延迟双删</strong></p><p>删除缓存 -&gt; 更新数据库 -&gt; 等待主从同步 -&gt; 再次删除缓存</p></li></ol><p><strong>总结</strong></p><ul><li>对一致性要求高：<strong>延迟双删</strong> + <strong>重试机制</strong> + <strong>强制读主库</strong></li><li>对性能要求高：使用 <strong>TTL</strong> 兜底</li><li>折中：引入 <strong>MQ</strong> 异步处理</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h1&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;</summary>
      
    
    
    
    <category term="Redis" scheme="https://xten-no-brain.github.io/categories/Redis/"/>
    
    
    <category term="开发组件" scheme="https://xten-no-brain.github.io/tags/%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="https://xten-no-brain.github.io/2025/04/27/MySQL/"/>
    <id>https://xten-no-brain.github.io/2025/04/27/MySQL/</id>
    <published>2025-04-27T13:59:37.000Z</published>
    <updated>2025-05-07T04:04:08.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>MySQL分为 <strong>Server 层</strong>和<strong>存储引擎层</strong></p><p><strong>Server 层</strong>包含连接器、查询缓存、解析器、预处理器、优化器、执行器</p><p><strong>存储引擎层</strong>包含 InnoDB、MyISAM 等存储引擎以及数据</p><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><p>从连接器开始，基于TCP协议确定客户端是否连接成功。连接成功后，当服务端收到客户端的 SQL 语句后，先以<strong>Key-Value</strong>形式到查询缓存里查看是否有这条SQL语句，如果有，则直接返回相应的 Value，即查询结果。若没有，则</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID四大特性"><a href="#ACID四大特性" class="headerlink" title="ACID四大特性"></a>ACID四大特性</h2><p>A：atomicity，原子性。通过 Undo log 实现</p><p>C：consistency，一致性。通过其它三个特性和应用层逻辑实现</p><p>I：isolation，隔离性。通过 MVCC 和锁实现</p><p>D：durability，持久性。通过 Redo log 实现</p><p>虽称为四大特性，但并不平级，<strong>AID</strong> 是为了达到 <strong>C</strong> 这一目标的手段</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>RU，读未提交：一个事务还未提交时，其他事务就能看到它做的变更</li><li>RC，读已提交：一个事务提交后，其他事务才能看到它做的变更</li><li>RR，可重复读：一个事务执行过程中，看到的数据都是一致的，InnoDB 默认隔离级别</li><li>Serializable，串行化：对记录加读写锁，当多个事务对同一记录做读写操作时，若发生冲突，则按顺序执行操作</li></ul><p>隔离级别：RU &lt; RC &lt; RR &lt; Serializable</p><p>并发性能：RU &gt; RC &gt; RR &gt; Serializable</p><p><strong>分别是如何实现的？</strong></p><ul><li>RU：直接读取最新数据，包括其它数据未提交的修改；写操作对行加排他锁（X锁），读操作不加锁</li><li>RC：每次查询生成一个 Read View 视图；写操作加 X 锁，事务提交后释放</li><li>RR：事务的首次查询生成 Read View 视图，整个事务期间都使用该视图，保证一致性；写操作加行锁和临键锁（Next-Key Lock）</li><li>串行化：读操作隐式转换为 SELECT … LOCK IN SHARE MODE，加共享锁（S锁），写操作加 X 锁</li></ul><p><strong>各自会造成什么问题？</strong></p><table><thead><tr><th align="center">读未提交</th><th align="center">读已提交</th><th align="center">可重复读</th><th align="center">串行化</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">不可重复读</td><td align="center">不可重复读</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">幻读</td><td align="center">幻读</td><td align="center">极少的幻读</td><td align="center"></td></tr></tbody></table><p>脏读：读到其他事务还未提交的数据</p><p>不可重复读：一个事务内多次查询同一字段，前后数据内容不一致</p><p>幻读：一个事务内多次查询同一字段，前后记录数量不一致</p><p>严重性：脏读 &gt; 不可重复读 &gt; 幻读</p><p><strong>可重复读如何避免幻读？</strong></p><ul><li>快照读：通过 MVCC，保证事务期间的 Read View 视图一致</li><li>当前读：SELECT … FOR UPDATE，通过临键锁阻塞其他事务在此锁范围内插入记录</li></ul><p>无法解决的幻读：</p><p>单纯的快照读或当前读都不会导致幻读现象，交叉使用时才有可能导致幻读</p><ul><li>快照读时：事务A开启后，事务B执行了插入操作，且事务A使用了 UPDATE 进行更新，后续事务A可以读到这条记录，导致幻读</li><li>当前读时：事务开启后，先执行快照读，其他事务进行插入操作，后续执行  SELECT … FOR UPDATE 或 SELECT … IN SHARE MODE，发现前后记录数量不一样，导致幻读</li></ul><p>共享锁、互斥锁兼容性</p><table><thead><tr><th align="center"></th><th align="center">X 锁</th><th align="center">S 锁</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center">✅</td></tr></tbody></table><p><strong>为什么默认隔离级别为 RR，阿里却用 RC ？</strong></p><ul><li>当前业务场景下，幻读的影响不大</li><li>提高并发性能</li></ul><p><strong>为什么不采用串行化，避免所有事务问题？</strong></p><p>串行化的并发性能过低</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;架构&quot;&gt;&lt;a href=&quot;#架构&quot; class=&quot;headerlink&quot; title=&quot;架构&quot;&gt;&lt;/a&gt;架构&lt;/h1&gt;&lt;p&gt;MySQL分为 &lt;strong&gt;Server 层&lt;/strong&gt;和&lt;strong&gt;存储引擎层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;stron</summary>
      
    
    
    
    <category term="MySQL" scheme="https://xten-no-brain.github.io/categories/MySQL/"/>
    
    
    <category term="开发组件" scheme="https://xten-no-brain.github.io/tags/%E5%BC%80%E5%8F%91%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
</feed>
