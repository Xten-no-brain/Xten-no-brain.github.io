<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式</title>
      <link href="/2025/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2025/06/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 补充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/2025/06/10/Linux/"/>
      <url>/2025/06/10/Linux/</url>
      
        <content type="html"><![CDATA[<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><p>awk</p><p>sed</p><p>grep</p><p>coredump</p><p>netstat</p><p>tcpdump</p><p>ipcs</p><p>ipcrm</p><h1 id="GDB"><a href="#GDB" class="headerlink" title="GDB"></a>GDB</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMake</title>
      <link href="/2025/06/10/CMake/"/>
      <url>/2025/06/10/CMake/</url>
      
        <content type="html"><![CDATA[<h1 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a>CMakeLists.txt</h1><h1 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h1><h2 id="开发常用命令"><a href="#开发常用命令" class="headerlink" title="开发常用命令"></a>开发常用命令</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看，需要修改 D:\file</span></span><br><span class="line"><span class="built_in">ls</span> <span class="comment"># 当前目录下所有</span></span><br><span class="line"><span class="built_in">ls</span> <span class="string">&quot;D:\file&quot;</span> <span class="literal">-r</span> <span class="comment"># 特定目录下的文件和子目录</span></span><br><span class="line"><span class="built_in">ls</span> <span class="string">&quot;D:\file&quot;</span> <span class="literal">-fi</span> <span class="comment"># 查看特定目录下的文件</span></span><br><span class="line"><span class="built_in">ls</span> <span class="string">&quot;D:\file&quot;</span> <span class="literal">-di</span> <span class="comment"># 查看特定目录下的子目录</span></span><br><span class="line"><span class="built_in">ls</span> <span class="string">&quot;D:\file&quot;</span> <span class="literal">-fi</span> <span class="string">&quot;*.cpp&quot;</span> <span class="comment"># 通配符查找特定目录下的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除，需要修改 D:\file</span></span><br><span class="line"><span class="built_in">ri</span> .\file\ <span class="literal">-r</span> <span class="literal">-fo</span> <span class="comment"># 强制删除所有子项</span></span><br><span class="line"><span class="built_in">rm</span> .\file\* <span class="operator">-in</span> *.tmp <span class="literal">-Recurse</span> <span class="comment"># 删除 *.tmp 的文件，视情况修改条件</span></span><br><span class="line"><span class="built_in">rm</span> .\file\* <span class="literal">-ex</span> *.tmp <span class="literal">-Recurse</span> <span class="comment"># 保留 *.tmp 的文件，视情况修改条件</span></span><br><span class="line"><span class="built_in">rm</span> .\file <span class="literal">-r</span> <span class="literal">-wi</span> <span class="comment"># 预览将要执行的删除操作效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建</span></span><br><span class="line"><span class="built_in">ni</span> .\folder <span class="literal">-t</span> d <span class="comment"># 需要修改 folder</span></span><br><span class="line"><span class="built_in">ni</span> <span class="string">&quot;D:\file\project&quot;</span> <span class="literal">-t</span> f <span class="comment"># 需要修改 D:\file\projec</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 导航，需要修改 file</span></span><br><span class="line"><span class="built_in">cd</span> file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前目录</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 清屏</span></span><br><span class="line"><span class="built_in">cls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">cmake .. <span class="literal">-G</span> <span class="string">&quot;Visual Studio 17 2022&quot;</span> <span class="comment"># 以 VS2022 进行编译，视情况修改引号中的内容</span></span><br><span class="line">cmake .. <span class="literal">-G</span> <span class="string">&quot;Visual Studio 17 2022&quot;</span> <span class="comment"># 若省略 -A 参数，默认生成 32 位</span></span><br><span class="line">cmake .. <span class="literal">-G</span> <span class="string">&quot;Visual Studio 17 2022&quot;</span> <span class="literal">-A</span> x64 <span class="comment"># 生成 64 位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Debug 模式</span></span><br><span class="line">cmake <span class="literal">--build</span> . <span class="literal">--config</span> Debug</span><br><span class="line"></span><br><span class="line"><span class="comment"># Release 模式</span></span><br><span class="line">cmake <span class="literal">--build</span> . <span class="literal">--config</span> Release</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件是否存在，需修改 path</span></span><br><span class="line"><span class="built_in">Test-Path</span> <span class="literal">-Path</span> &lt;path&gt;</span><br></pre></td></tr></table></figure><h2 id="检查缺失文件"><a href="#检查缺失文件" class="headerlink" title="检查缺失文件"></a>检查缺失文件</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 项目根目录（根据实际情况修改）</span></span><br><span class="line"><span class="variable">$projectRoot</span> = <span class="string">&quot;D:\CocosProjects\MyCardGameClean&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># CMakeLists.txt 路径（你可以根据实际修改）</span></span><br><span class="line"><span class="variable">$cmakeFile</span> = <span class="built_in">Join-Path</span> <span class="variable">$projectRoot</span> <span class="string">&quot;CMakeLists.txt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取 CMakeLists.txt 文件内容</span></span><br><span class="line"><span class="variable">$content</span> = <span class="built_in">Get-Content</span> <span class="variable">$cmakeFile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则匹配所有可能的 .cpp 文件路径（简单匹配以 .cpp 结尾的字符串）</span></span><br><span class="line"><span class="comment"># 这里假设文件路径写在双引号内或直接写，且包含 &#x27;Classes/&#x27; 或 &#x27;src/&#x27; 目录</span></span><br><span class="line"><span class="comment"># 你可以根据实际格式微调正则</span></span><br><span class="line"><span class="variable">$pattern</span> = <span class="string">&#x27;(Classes[^\s&quot;\)]+\.cpp)|(src[^\s&quot;\)]+\.cpp)&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到所有匹配的文件路径（相对路径）</span></span><br><span class="line"><span class="variable">$matches</span> = [<span class="type">regex</span>]::Matches(<span class="variable">$content</span>, <span class="variable">$pattern</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重，避免重复检查</span></span><br><span class="line"><span class="variable">$filePaths</span> = <span class="variable">$matches</span> | <span class="built_in">ForEach-Object</span> &#123; <span class="variable">$_</span>.Groups[<span class="number">1</span>].Value &#125; | <span class="built_in">Select-Object</span> <span class="literal">-Unique</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查每个文件是否存在</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$filePath</span> <span class="keyword">in</span> <span class="variable">$filePaths</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">-not</span> [<span class="built_in">string</span>]::IsNullOrEmpty(<span class="variable">$filePath</span>)) &#123;</span><br><span class="line">        <span class="variable">$fullPath</span> = <span class="built_in">Join-Path</span> <span class="variable">$projectRoot</span> <span class="variable">$filePath</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">-Not</span> (<span class="built_in">Test-Path</span> <span class="variable">$fullPath</span>)) &#123;</span><br><span class="line">            <span class="built_in">Write-Output</span> <span class="string">&quot;缺失文件: <span class="variable">$filePath</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Write-Output</span> <span class="string">&quot;检查完成。&quot;</span></span><br></pre></td></tr></table></figure><p><strong>如何使用？</strong></p><ol><li><p>打开 PowerShell</p></li><li><p>使用 <code>cd</code> 命令导航到脚本所在的目录。例如，如果脚本保存在桌面，可以执行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/Desktop</span><br></pre></td></tr></table></figure></li><li><p>运行脚本：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\check_files.ps1 <span class="comment"># 脚本文件名</span></span><br></pre></td></tr></table></figure></li></ol><p>如果遇到权限问题，可能需要临时启用脚本执行：</p><ol><li><p>打开 PowerShell，以管理员权限运行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> <span class="keyword">Process</span></span><br></pre></td></tr></table></figure></li><li><p>再次运行脚本</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git</title>
      <link href="/2025/06/10/Git/"/>
      <url>/2025/06/10/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="开发常用命令"><a href="#开发常用命令" class="headerlink" title="开发常用命令"></a>开发常用命令</h1><h2 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有文件到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加特定文件到暂存区，需要修改 file_path</span></span><br><span class="line">git add &lt;file_path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区状态</span></span><br><span class="line">git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除暂存区</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="literal">-r</span> <span class="literal">--cached</span> .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交更改</span></span><br><span class="line">git commit <span class="literal">-m</span> <span class="string">&quot;commit 注释&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push origin master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目前被追踪文件</span></span><br><span class="line">git <span class="built_in">ls</span><span class="literal">-files</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定目录下的被追踪文件，需要修改 dir</span></span><br><span class="line">git <span class="built_in">ls</span><span class="literal">-files</span> <span class="built_in">dir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除不需要追踪的文件</span></span><br><span class="line">git <span class="built_in">rm</span> <span class="literal">--cached</span> &lt;file_path&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 SSH 转为 HTTPS，需要修改 username/repository</span></span><br><span class="line">git remote <span class="built_in">set-url</span> origin https://github.com/username/repository.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HTTPS 转为 SSH，需要修改 User 和 ssh_id</span></span><br><span class="line">git config <span class="literal">--global</span> core.sshCommand</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 SSH 配置</span></span><br><span class="line">ssh <span class="literal">-T</span> git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程连接方式，git 开头则为 SSH，HTTPS 开头为 HTTPS 连接</span></span><br><span class="line">git remote <span class="literal">-v</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂存区内容的大小</span></span><br><span class="line"><span class="comment"># BEGIN 无意义，只是方便阅读，不需要复制到终端</span></span><br><span class="line"><span class="comment"># 1. 获取暂存区所有文件的 SHA-1 哈希值</span></span><br><span class="line"><span class="variable">$blobs</span> = git <span class="built_in">ls</span><span class="literal">-files</span> <span class="literal">-s</span> | <span class="built_in">ForEach-Object</span> &#123; (<span class="variable">$_</span> <span class="operator">-split</span> <span class="string">&#x27;\s+&#x27;</span>)[<span class="number">1</span>] &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 计算所有对象的压缩大小总和（字节）</span></span><br><span class="line"><span class="variable">$totalBytes</span> = <span class="number">0</span></span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$blob</span> <span class="keyword">in</span> <span class="variable">$blobs</span>) &#123;</span><br><span class="line">    <span class="variable">$size</span> = git <span class="built_in">cat</span><span class="operator">-file</span> <span class="literal">-s</span> <span class="variable">$blob</span> <span class="number">2</span>&gt;<span class="variable">$null</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$size</span>) &#123; <span class="variable">$totalBytes</span> += [<span class="built_in">int</span>]<span class="variable">$size</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 格式化输出结果</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;Staging Area Size (Compressed in Git):&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;<span class="variable">$totalBytes</span> bytes&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;<span class="variable">$</span>([math]::Round(<span class="variable">$totalBytes</span> / 1KB, 2)) KB&quot;</span></span><br><span class="line"><span class="built_in">Write-Host</span> <span class="string">&quot;<span class="variable">$</span>([math]::Round(<span class="variable">$totalBytes</span> / 1MB, 2)) MB&quot;</span></span><br><span class="line"><span class="comment"># END 无意义，只是方便阅读，不需要复制到终端</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 Git 缓冲区大小</span></span><br><span class="line">git config <span class="literal">--global</span> http.postBuffer size <span class="comment"># 根据情况用数字替换 size，单位为字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否有大型文件</span></span><br><span class="line">git <span class="built_in">ls</span><span class="literal">-files</span> <span class="literal">-s</span> | <span class="built_in">sort</span> <span class="literal">-n</span> <span class="literal">-k</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到分支远程仓库 视情况修改 branch</span></span><br><span class="line">git push origin &lt;branch&gt; <span class="comment"># 普通推送，无额外功能</span></span><br><span class="line">git push <span class="literal">-u</span> origin &lt;branch&gt; <span class="comment"># 建立追踪关系，后续该分支可用 git push 直接推送</span></span><br><span class="line">git push <span class="operator">-f</span> origin &lt;branch&gt; <span class="comment"># 强制推送，会覆盖他人提交，只能用于个人分支</span></span><br><span class="line">git push <span class="literal">--force-with-lease</span> origin &lt;branch&gt; <span class="comment"># 安全强制推送，会检查分支是否有他人的新提交</span></span><br><span class="line">git push <span class="literal">--all</span> origin <span class="comment"># 推送所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">git push origin <span class="literal">--delete</span> &lt;branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送远程标签 需要修改 tagname</span></span><br><span class="line">git push origin &lt;tagname&gt; <span class="comment"># 单个标签</span></span><br><span class="line">git push origin <span class="literal">--tags</span> <span class="comment"># 所有本地标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程标签</span></span><br><span class="line">git push origin <span class="literal">--delete</span> &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/2025/05/20/C++/"/>
      <url>/2025/05/20/C++/</url>
      
        <content type="html"><![CDATA[<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>封装：隐藏内部实现细节，提供对外接口</li><li>继承：子类继承父类，实现代码复用与扩展</li><li>多态：同名方法不同实现<ul><li>静态多态（编译时多态）：通过函数重载、运算符重载、模板实现</li><li>动态多态（运行时多态）：通过<strong>虚函数</strong>和<strong>指针&#x2F;引用</strong>实现</li></ul></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="EBO-机制"><a href="#EBO-机制" class="headerlink" title="EBO 机制"></a>EBO 机制</h3><ul><li><p>一个空类 A，它的 sizeof(A) 是多少？</p><p>结果为 1，C++ 规定每个对象必须具有唯一的地址，因此即使为空类，也至少分配 1 个字节</p></li><li><p>如果还有一个空类 B 继承 A 呢？sizeof(B) 是多少？</p><p>sizeof(B) &#x3D; 1，当一个空类作为基类被继承时，编译器会将它的空间优化掉，这就是 EBO 机制</p></li><li><p>菱形继承（未解决二义性）四中个都为空类，派生类 D 的 sizeof 是多少？</p><p>sizeof(D) &#x3D; 1，派生类有两个 A 子对象，但它们占的空间都被优化掉了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A objA;</span><br><span class="line">B objB;</span><br><span class="line">C objC;</span><br><span class="line">D objD;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">sizeof</span>(objA);</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">sizeof</span>(objB);</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">sizeof</span>(objC);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">sizeof</span>(objD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出为 1 1 1 1</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>菱形继承（解决二义性）四中个都为空类，派生类 D 的 sizeof 是多少？</p><p>由于虚表指针的存在，64位系统下 sizeof(D) &#x3D; 16</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A objA;</span><br><span class="line">B objB;</span><br><span class="line">C objC;</span><br><span class="line">D objD;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="built_in">sizeof</span>(objA);</span><br><span class="line">    <span class="type">int</span> b = <span class="built_in">sizeof</span>(objB);</span><br><span class="line">    <span class="type">int</span> c = <span class="built_in">sizeof</span>(objC);</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">sizeof</span>(objD);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出为 1 8 8 16</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; c &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><br><br><br><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h2><h2 id="拷贝"><a href="#拷贝" class="headerlink" title="拷贝"></a>拷贝</h2><ul><li><p>深拷贝：不仅拷贝对象的成员变量，还会<strong>申请新的内存空间</strong>，并<strong>复制指针所指向的内容</strong></p><p>​        两个对象互相独立，互不影响</p></li><li><p>浅拷贝：拷贝对象的成员变量，若其为指针，<strong>只拷贝指针地址</strong>，而非指针指向内容</p><p>​        <strong>共享同一份资源</strong>，容易产生<strong>悬垂指针</strong>或者 <strong>Double Free</strong> 这种未定义行为</p></li><li><p>移动拷贝：<strong>转移资源所有权</strong>，规避深浅拷贝的问题</p></li></ul><p><strong>拷贝后修改原对象，拷贝对象是否会改变？</strong></p><p>深拷贝：不会改变，因为二者独立</p><p>浅拷贝：若为值对象，不会改变；若为指针，会跟着改变，因为二者共用一块内存</p><br><br><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="是否占空间？"><a href="#是否占空间？" class="headerlink" title="是否占空间？"></a>是否占空间？</h3><ul><li>类成员引用：占 1 个指针大小空间，因为需要持久绑定在某个对象上</li><li>函数参数引用：占 1 个指针大小空间，</li><li>普通局部引用：不占，底层的指针由汇编实现</li></ul><h3 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h3><p>类成员引用：汇编层面在对象内存中存储一个指针，通过解引用访问被引用对象</p><p>函数参数引用：汇编层面会将<strong>原对象的地址</strong>放到<strong>寄存器&#x2F;栈</strong>上，将其传给函数</p><p>普通局部引用：编译器直接展开引用为原对象的访问</p><h3 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h3><ul><li>引用声明时必须初始化，指针不用</li><li>引用不可初始化为空，指针可以</li><li>引用初始化后不可修改，指针可以</li><li>引用是<strong>原对象的别名</strong>，指针是独立的变量</li><li>sizeof：引用的结果与原对象相同，指针为 4 或 8 字节</li></ul><br><br><h2 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h2><br><br><br><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><br><br><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><br><br><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p><strong>遍历删除元素，需要注意什么？</strong></p><br><br><br><h1 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><h3 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h3><p>C++98 引入，11 弃用</p><p>早期的独占指针，但其在拷贝后会交换所有权，导致原指针变为悬垂指针，故被 unique_ptr 替代</p><br><h3 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h3><p>Boost 库中支持，更严格的 unique_ptr，不支持资源所有权转移、不可移动、也不支持 STL 容器</p><br><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>通过将<strong>拷贝构造</strong>和<strong>拷贝赋值</strong>绑定为 delete 实现独占；通过将<strong>对象生命周期</strong>与<strong>作用域</strong>绑定实现 RAII</p><p>支持<strong>移动构造</strong>和<strong>移动赋值</strong>转移所有权</p><br><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>通过<strong>控制块</strong>实现<strong>引用计数</strong>，当最后一个 shared_ptr 被销毁时，它所管理的资源才会被释放</p><p><strong>线程安全问题</strong></p><ul><li><p>引用计数是原子操作，保证线程安全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="type">int</span>&gt; count;</span><br><span class="line"></span><br><span class="line">count.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed); <span class="comment">// 增加引用计数</span></span><br><span class="line">count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_acq_rel); <span class="comment">// 减少引用计数</span></span><br></pre></td></tr></table></figure></li><li><p>shared_ptr 和所管理的对象并不保证线程安全，多线程下要加锁进行同步</p></li></ul><p><strong>与 make_shared 的区别</strong></p><ul><li><p>make_shared</p><p>在一<strong>连续的堆内存中</strong>，同时分配<strong>对象</strong>和<strong>控制块</strong>。只 new 一次，更节省内存且更高效</p><p><strong>对象</strong>和<strong>控制块</strong>绑定在一起，需要<strong>一起释放</strong></p><p>不支持自定义<strong>删除器</strong></p></li><li><p>shared_ptr</p><p>先给<strong>对象</strong>分配内存，再给<strong>控制块</strong>分配内存，需要 new 两次</p><p><strong>对象</strong>和<strong>控制块</strong>可以分开释放</p><p>支持自定义删除器</p></li></ul><p><strong>enable_shared_from_this</strong></p><p>用于从<strong>对象内部</strong>拿到一个 shared_ptr</p><ul><li>使用 shared_ptr 会开一个<strong>新的引用计数</strong>，最终对象会被 delete 两次（导致系统崩溃）</li><li>shared_from_this 从<strong>内部隐藏</strong>的 weak_ptr 提升出一个 shared_ptr，加入当前对象的控制块，保证  引用计数正确</li></ul><p>简化代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">enable_shared_from_this</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> std::weak_ptr&lt;T&gt; weak_this; <span class="comment">// 保存一个弱引用指向自己</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">shared_from_this</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">shared_ptr</span>&lt;T&gt;(weak_this); <span class="comment">// 提升成 shared_ptr</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">std</span>::shared_ptr&lt;T&gt;; <span class="comment">// 允许 shared_ptr 内部设置 weak_this</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>观察但不拥有资源，用于打破 shared_ptr 的循环引用，必须与 shared_ptr 配套出现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span>; <span class="comment">// 前向声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;B&gt; ptr_to_b;</span><br><span class="line">    ~<span class="built_in">A</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;A destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果这里是 shared_ptr，会导致循环引用</span></span><br><span class="line">    std::weak_ptr&lt;A&gt; ptr_to_a;  <span class="comment">// 改成 weak_ptr 解决循环引用</span></span><br><span class="line">    ~<span class="built_in">B</span>() &#123; std::cout &lt;&lt; <span class="string">&quot;B destroyed\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;A&gt; a = std::<span class="built_in">make_shared</span>&lt;A&gt;();</span><br><span class="line">    std::shared_ptr&lt;B&gt; b = std::<span class="built_in">make_shared</span>&lt;B&gt;();</span><br><span class="line"></span><br><span class="line">    a-&gt;ptr_to_b = b;</span><br><span class="line">    b-&gt;ptr_to_a = a;  <span class="comment">// weak_ptr 不增加引用计数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="对比裸指针"><a href="#对比裸指针" class="headerlink" title="对比裸指针"></a>对比裸指针</h3><table><thead><tr><th align="center"></th><th align="center">智能指针</th><th align="center">裸指针</th></tr></thead><tbody><tr><td align="center"><strong>内存管理</strong></td><td align="center">自动释放资源，避免泄漏和重复释放</td><td align="center">手动管理，容易泄漏或双重释放</td></tr><tr><td align="center"><strong>所有权表达</strong></td><td align="center">明确表达“拥有”、“共享”或“观察”的语义（如 <code>unique_ptr</code> &#x2F; <code>shared_ptr</code> &#x2F; <code>weak_ptr</code>）</td><td align="center">无所有权语义，容易误用</td></tr><tr><td align="center"><strong>线程安全</strong></td><td align="center"><code>shared_ptr</code> 是线程安全的（引用计数），但会牺牲性能</td><td align="center">非线程安全，需手动加锁</td></tr><tr><td align="center"><strong>容器兼容性</strong></td><td align="center"><code>unique_ptr</code> &#x2F; <code>shared_ptr</code> 可与 STL 容器无缝配合</td><td align="center">可配合使用，但要手动管理释放</td></tr><tr><td align="center"><strong>性能开销</strong></td><td align="center">引入一定开销：构造、析构、移动、引用计数（特别是 <code>shared_ptr</code>）</td><td align="center">性能极轻量，无额外开销</td></tr><tr><td align="center"><strong>循环引用风险</strong></td><td align="center"><code>shared_ptr</code> 容易产生循环引用，需配合 <code>weak_ptr</code></td><td align="center">没有引用计数，不会循环引用</td></tr><tr><td align="center"><strong>内存布局&#x2F;碎片</strong></td><td align="center">存在控制块（特别是 <code>shared_ptr</code>），可能导致额外内存开销或碎片</td><td align="center">紧凑、内存结构清晰</td></tr><tr><td align="center"><strong>使用场景</strong></td><td align="center">推荐用于拥有动态资源的类和结构体，RAII 场景</td><td align="center">推荐用于轻量访问、非拥有资源场景</td></tr></tbody></table><br><br><h2 id="Lambda-与捕获列表"><a href="#Lambda-与捕获列表" class="headerlink" title="Lambda 与捕获列表"></a>Lambda 与捕获列表</h2><br><br><h2 id="move-语义"><a href="#move-语义" class="headerlink" title="move 语义"></a>move 语义</h2><p>将左值强转为右值，调用移动构造函数，转移资源所有权</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> std::remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">高地址</span><br><span class="line">│</span><br><span class="line">├── 栈区（Stack）</span><br><span class="line">│   - 函数调用相关：局部变量、返回地址、参数等</span><br><span class="line">│   - 自动分配和释放，后进先出（LIFO）</span><br><span class="line">│</span><br><span class="line">├── 堆区（Heap）</span><br><span class="line">│   - 动态分配内存（malloc/new 等）</span><br><span class="line">│   - 需要程序员手动释放（free/delete）</span><br><span class="line">│</span><br><span class="line">├── BSS段（未初始化的全局变量）</span><br><span class="line">│</span><br><span class="line">├── 数据段（已初始化的全局变量/静态变量）</span><br><span class="line">│</span><br><span class="line">├── 只读数据段（常量区）</span><br><span class="line">│   - 字符串常量、const 修饰的全局常量等</span><br><span class="line">│</span><br><span class="line">├── 代码段（Text Segment）</span><br><span class="line">│   - 存放程序的机器指令</span><br><span class="line">│</span><br><span class="line">└──</span><br><span class="line">低地址</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><br><h2 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h2><p><strong>规则</strong>：结构体整体大小是最大对齐值的倍数，可用<code>#pragam pack(n)</code>限制最大对齐值为 n </p><p><strong>好处</strong></p><ul><li>提高访问效率：CPU 按字长来读取内存，对齐后 CPU 可以一次性读取完成</li><li>跨平台支持：保证不同平台和编译器之间二进制兼容</li><li>硬件限制：某些平台不支持非对齐访问，否则系统会崩溃</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计</title>
      <link href="/2025/05/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2025/05/19/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Xten-no-brain/RaftKV</span><br><span class="line">准备写一个分布式KV的轮子项目，故补充一下分布式相关的知识</span><br><span class="line">下列提到的还处于了解阶段，待后续深入后再修改</span><br></pre></td></tr></table></figure><h2 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h2><ul><li>一致性（Consistency）：所有节点在同一时间的数据完全一致</li><li>可用性（Availability）：每个请求都能得到响应（不保证数据最新）</li><li>分区容忍性（Partition Tolerance）：系统能容忍网络分区故障</li></ul><p><strong>三者不可兼得，最多满足两项</strong></p><p>因为分布式系统中，<strong>网络分区</strong>是不可避免的，故只有两种系统</p><ol><li>CP：强一致性、容错，但不一定总可用</li><li>AP：高可用、容错，但可能短时间不一致</li></ol><p><strong>如何选取？</strong></p><br><br><h2 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h2><p><strong>对 CAP 中 AP 场景的扩展</strong></p><p>基本可以：系统故障时仍能提供部分功能</p><p>软状态：允许中间状态存在</p><p>最终一致性：数据经过一段时间后达成一致</p><br><br><h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><ul><li>强一致性</li><li>线性一致性</li><li>因果一致性</li><li>会话一致性</li><li>最终一致性</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><ul><li>两阶段提交（2PC）</li><li>三阶段提交（3PC）</li><li>TCC 模型</li><li>SAGA 模型</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="副本同步"><a href="#副本同步" class="headerlink" title="副本同步"></a>副本同步</h2><ul><li>主从复制（同步 &#x2F; 异步 &#x2F; 半同步）</li><li>Quorum 机制</li><li>Raft &#x2F; Paxos 简介</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><ul><li>静态配置</li><li>动态注册与发现（Consul &#x2F; Etcd &#x2F; Zookeeper）</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="全局分布式-ID"><a href="#全局分布式-ID" class="headerlink" title="全局分布式 ID"></a>全局分布式 ID</h2><ul><li>UUID</li><li>Redis 生成 ID</li><li>雪花算法</li><li>Leaf（美团开源）</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><ul><li>轮询</li><li>加权轮询</li><li>一致性哈希</li><li>随机</li><li>IP Hash</li><li>基于连接数 &#x2F; RTT 动态调整</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h2><ul><li>设计方法<ul><li>唯一流水号</li><li>幂等表</li><li>业务逻辑保障</li></ul></li></ul><p><strong>典型场景</strong></p><br><br><h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><ul><li>强一致性</li><li>最终一致性</li><li>事件驱动架构</li><li>消息队列一致性保障</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><ul><li>基于数据库</li><li>基于 Redis</li><li>基于 Zookeeper</li><li>可重入 &#x2F; 非可重入</li><li>防止死锁设计</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>Kafka &#x2F; RabbitMQ &#x2F; RocketMQ &#x2F; Pulsar</li><li>消息一致性保障</li><li>消息幂等性设计</li><li>消息顺序性设计</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="高可用设计"><a href="#高可用设计" class="headerlink" title="高可用设计"></a>高可用设计</h2><ul><li>Leader 选举</li><li>多活架构 vs 主备架构</li><li>灾备策略</li></ul><p><strong>如何选取？</strong></p><br><br><h2 id="扩展性设计"><a href="#扩展性设计" class="headerlink" title="扩展性设计"></a>扩展性设计</h2><ul><li>横向扩展</li><li>无中心设计 vs 有中心设计</li><li>分区与分片策略</li></ul><br><br><br><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><ul><li>本地缓存 vs 分布式缓存</li><li>缓存一致性策略<ul><li>Cache Aside</li><li>Write Through</li><li>Write Behind</li></ul></li><li>缓存雪崩 &#x2F; 穿透 &#x2F; 击穿</li></ul><p><strong>如何选取？</strong></p><br><br><br><h1 id="限流机制"><a href="#限流机制" class="headerlink" title="限流机制"></a>限流机制</h1><ul><li>固定窗口</li><li>滑动窗口</li><li>漏桶算法</li><li>令牌桶算法</li></ul><p><strong>如何选取？</strong></p><br><br><br><h1 id="熔断-降级-容错"><a href="#熔断-降级-容错" class="headerlink" title="熔断 &#x2F; 降级 &#x2F; 容错"></a>熔断 &#x2F; 降级 &#x2F; 容错</h1><ul><li>熔断器（Hystrix &#x2F; Sentinel）</li><li>超时控制</li><li>自动恢复机制</li></ul><p><strong>如何选取？</strong></p><br><br><br><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="短链生成系统"><a href="#短链生成系统" class="headerlink" title="短链生成系统"></a>短链生成系统</h2><br><br><h2 id="分布式-ID-生成器"><a href="#分布式-ID-生成器" class="headerlink" title="分布式 ID 生成器"></a>分布式 ID 生成器</h2><br><br><h2 id="高并发秒杀系统"><a href="#高并发秒杀系统" class="headerlink" title="高并发秒杀系统"></a>高并发秒杀系统</h2><br><br><h2 id="分布式文件存储系统"><a href="#分布式文件存储系统" class="headerlink" title="分布式文件存储系统"></a>分布式文件存储系统</h2><br><br><h2 id="分布式锁实践"><a href="#分布式锁实践" class="headerlink" title="分布式锁实践"></a>分布式锁实践</h2><br><br><h2 id="消息队列实践"><a href="#消息队列实践" class="headerlink" title="消息队列实践"></a>消息队列实践</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 架构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络</title>
      <link href="/2025/04/27/%E7%BD%91%E7%BB%9C/"/>
      <url>/2025/04/27/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP相关"><a href="#TCP相关" class="headerlink" title="TCP相关"></a>TCP相关</h1><h2 id="如何保证可靠传输"><a href="#如何保证可靠传输" class="headerlink" title="如何保证可靠传输"></a>如何保证可靠传输</h2><ul><li><p>三次握手建立连接</p></li><li><p>序列号和确认号保证有序传输</p><p>每个数据带有序号 seq，接收方返回 ack  告知发送方已接受到数据，可以继续发送</p></li><li><p>重传机制</p><ul><li>超时重传，超时还未收到 akc 后，重传可能丢失的数据</li><li>快速重传，当连续收到三个相同 ack 后，立即重传可能丢失的数据</li></ul></li><li><p>流量控制</p><p>维护一个代表接收能力的滑动窗口，若接收缓冲区快满了，就缩小窗口，反之扩大窗口</p></li><li><p>拥塞控制</p><p>网络拥堵时，TCP 会减慢发送速度，防止因网络拥堵丢失大量数据</p></li><li><p>四次挥手断开连接</p></li></ul><br><br><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>假设客户端为 A，服务器为 B</p><ul><li><strong>第一次握手（SYN）</strong><ul><li>A 发送一个 SYN 包给 B，请求建立连接</li><li>进入 <code>SYN_SENT</code> 状态</li></ul></li><li><strong>第二次握手（SYN-ACK）</strong><ul><li>B 收到后，回复一个 SYN-ACK 包，表示同意连接，并请求建立反方向连接</li><li>B 进入 <code>SYN_RCVD</code> 状态</li><li>此时为<strong>半连接队列</strong></li></ul></li><li><strong>第三次握手（ACK）</strong><ul><li>A 收到后，发送一个 ACK 包给 B，表示连接建立成功</li><li>A 进入 <code>ESTABLISHED</code> 状态，B 收到ACK后也进入 <code>ESTABLISHED</code> 状态</li><li>此时为<strong>全连接队列</strong></li></ul></li></ul><p>此时，连接正式建立，双方向都可以开始发送数据了</p><p><strong>为什么不是两次？</strong></p><p>两次只进行到 B 回复 SYN-ACK 包，A 只知道 B 收到了自己的请求，但不知道 B 是否准备好接受数据</p><p><strong>为什么不是四次？</strong></p><p>三次已经保证双方都能接收和发送数据，无需再做一次</p><p>也可以将 B 给 A 的包拆成 SYN 和 ACK 分开发送，但没必要</p><br><br><h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>假设客户端为 A，服务器为 B</p><ul><li><p><strong>第一次挥手（FIN）</strong></p><p> A 发送一个 FIN 报文，表示它已经没有数据要发送了，请求关闭连接</p></li><li><p><strong>第二次挥手（ACK）</strong></p><p>B 收到 FIN 报文后，发送一个 ACK 报文作为确认。此时 A 到 B 的数据通道关闭，但 B 还可以继续发数据给 A</p></li><li><p><strong>第三次挥手（FIN）</strong></p><p>B 完成自己的数据发送后，也发送一个 FIN 报文，请求关闭连接</p></li><li><p><strong>第四次挥手（ACK）</strong></p><p>A 收到 FIN 报文后，发送一个 ACK 报文确认。此时，整个连接关闭</p></li><li><p><strong>进入 TIME_WAIT</strong></p><p>强制等待 2MSL（两倍最大报文段生存时间），即一个来回的时间</p><p>防止旧连接中还在路上的数据包被新连接接收</p><p>确保最后一个 ACK 被对方收到，保证整个连接关闭</p></li></ul><p><strong>为什么不能三次？</strong></p><p>TCP 是双向通信，双方都可以接收和发送数据，三次挥手只能关闭一个方向，导致一方的数据未发完</p><p><strong>为什么不是五次？</strong></p><p>四次已经能实现双向关闭，额外的操作会浪费资源</p><p><strong>挥手过程双端分别经历哪些状态？</strong></p><p><strong>TIME_WAIT 过多</strong></p><p>占用大量端口，影响并发性能</p><p>解决方案</p><ul><li>端口复用</li><li>使用长连接</li></ul><br><br><br><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><p>TCP 与 UDP 的区别</p><p>长连接和短连接</p><br><br><br><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p><strong>为什么物联网设备用 MQTT 而非 HTTP？</strong></p><ul><li>轻量级<ul><li>物联网设备一般性能低、带宽小、电池供电，MQTT 的开销小，消息格式简单，很适用</li><li>HTTP 需要传输完整的 HTTP 头，建立和关闭 TCP 连接，开销大</li></ul></li><li>实时性和长连接<ul><li>MQTT 支持<strong>长连接</strong>，可以实时推送数据（比如传感器数据、设备状态）</li><li>HTTP 是<strong>短连接</strong>，响应一次就关闭连接，不适用于实时或高频数据流</li></ul></li><li>发布&#x2F;订阅模型<ul><li>MQTT 用 Pub&#x2F;Sub 模型，一个传感器端数据可以同时推送给多个订阅者（如多个监控系统）</li><li>HTTP 是点对点的请求&#x2F;响应，设备需要主动请求，不利于<strong>事件驱动</strong>的物联网场景</li></ul></li><li>不稳定网络适应性<ul><li>MQTT 有 QoS（质量服务等级）机制，支持在不稳定网络中保持消息可靠送达</li><li>HTTP 在网络抖动、掉线场景下，恢复成本高、体验差</li></ul></li></ul><p><strong>QoS 是怎么做的？</strong></p><ul><li>QoS 0 - 至多一次<ul><li>流程：发送方直接发送 <strong>PUBLISH</strong> 消息，不需要接收方 <strong>ACK</strong> 确认</li><li>特点：快、消息可能丢失、<strong>适用于不重要&#x2F;高频&#x2F;实时数据，如温度曲线</strong></li></ul></li><li>QoS 1 - 至少一次<ul><li>流程：发送方发送带<strong>消息 ID</strong>（用于重传识别） 的 <strong>PUBLISH</strong> 消息，接收方收到后立即回复 <strong>PUBACK</strong> 确认，若发送方长时间没收到 <strong>PUBACK</strong>，会重发 <strong>PUBLISH</strong> 直至收到 <strong>PUBACK</strong></li><li>特点：确保至少送达一次、可能重复（手动去重）、<strong>适合重要但可容忍重复的场景，如告警通知</strong></li></ul></li><li>QoS 2 - 恰好一次<ul><li>流程：发送方发送带<strong>消息 ID</strong> 的 <strong>PUBLISH</strong>，接收方收到后回复 <strong>PUBREC</strong> 表示已接收，发送方收到 <strong>PUBREC</strong> 后，发送 <strong>PUBREL</strong> 释放消息，接收方收到 <strong>PUBREL</strong>，处理消息，回复 <strong>PUBCOMP</strong> 完成</li><li>特点：确保仅送达一次、无重复、网络开销大，流程复杂、<strong>适于需要严格保证幂等的数据传输，如金融交易、计费场景</strong></li></ul></li></ul><p><strong>幂等是什么？</strong></p><p>同一个操作执行一次或多次，系统的最终结果是一样的</p><p>实现方法</p><ul><li>每个消息带唯一 ID，记录已处理过的消息，遇到重复的直接忽略</li><li>插入数据库时加唯一索引，保证不重复插入</li><li>数据库事务内判断是否已处理，未处理才执行操作</li></ul><br><br><br><h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p>自上而下</p><ol><li><strong>应用层</strong>：HTTP、HTTPS</li><li><strong>表示层</strong>：SSL&#x2F;TLS</li><li><strong>会话层</strong>：RPC</li><li><strong>传输层</strong>：TCP、UDP</li><li><strong>网络层</strong>：IP</li><li><strong>数据链路层</strong>：以太网</li><li><strong>物理层</strong>：光纤、网线</li></ol><br><br><h2 id="五层模型"><a href="#五层模型" class="headerlink" title="五层模型"></a>五层模型</h2><p>自上而下</p><ol><li><strong>应用层</strong>：HTTP、HTTPS</li><li><strong>传输层</strong>：TCP、UDP</li><li><strong>网络层</strong>：IP</li><li><strong>数据链路层</strong>：以太网</li><li><strong>物理层</strong>：光纤、网线</li></ol><br><br><h2 id="TCP-IP-四层模型"><a href="#TCP-IP-四层模型" class="headerlink" title="TCP&#x2F;IP 四层模型"></a>TCP&#x2F;IP 四层模型</h2><p>自上而下</p><ol><li><strong>应用层</strong>：HTTP、HTTPS</li><li><strong>传输层</strong>：TCP、UDP</li><li><strong>网络层</strong>：IP</li><li><strong>网络接口层</strong>：以太网、WIFI</li></ol><br><br><br><h1 id="网络-I-O-模型"><a href="#网络-I-O-模型" class="headerlink" title="网络 I&#x2F;O 模型"></a>网络 I&#x2F;O 模型</h1><h2 id="I-O-多路复用"><a href="#I-O-多路复用" class="headerlink" title="I&#x2F;O 多路复用"></a>I&#x2F;O 多路复用</h2><p>一个或少量线程&#x2F;进程中同时监听多个 I&#x2F;O 事件，提高系统效率，适用于高并发场景</p><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><p>早期的I&#x2F;O多路复用机制，使用固定长度的数组表示文件描述符集。每次调用<code>select</code>时都需要重新构建和检查文件描述符集</p><p><strong>支持的文件描述符数量有限</strong>（通常为1024），在大规模连接的场景下效率较低</p><br><h3 id="Poll"><a href="#Poll" class="headerlink" title="Poll"></a>Poll</h3><p><code>poll</code>与<code>select</code>类似，但<strong>使用动态数组</strong>来存储文件描述符，因此没有<code>select</code>的最大连接数限制</p><p><strong>每次调用时仍需遍历全部描述符</strong>，在处理大量连接时效率不高</p><br><h3 id="Epoll"><a href="#Epoll" class="headerlink" title="Epoll"></a>Epoll</h3><p>基于<strong>事件机制</strong>的 I&#x2F;O 多路复用，当事件发生时，才会通知程序</p><h4 id="LT-水平触发"><a href="#LT-水平触发" class="headerlink" title="LT 水平触发"></a>LT 水平触发</h4><p>只要时间处于活跃状态，就会一直通知程序，可能导致程序收到大量重复通知，增加开销</p><h4 id="ET-边缘触发"><a href="#ET-边缘触发" class="headerlink" title="ET 边缘触发"></a>ET 边缘触发</h4><p>仅在事件状态发生时通知程序，提高系统效率</p><p><strong>ET 模式下如何保证数据全部读完？</strong></p><p>ET 模式下，内核只通知一次，所以你必须<strong>循环读取直到读不到数据为止</strong>，即读取返回 <code>EAGAIN</code> 或 <code>EWOULDBLOCK</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 数据已全部读取完</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发生错误，处理错误</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对方关闭连接</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 处理读取到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><br><br><h1 id="网络问题排查"><a href="#网络问题排查" class="headerlink" title="网络问题排查"></a>网络问题排查</h1><h2 id="客户端发送数据给服务器，服务器没反应"><a href="#客户端发送数据给服务器，服务器没反应" class="headerlink" title="客户端发送数据给服务器，服务器没反应"></a>客户端发送数据给服务器，服务器没反应</h2><p><strong>send() 返回成功后，数据一定发送出去了吗？</strong></p><p><code>send()</code> 返回成功只代表数据已成功复制到内核的发送缓冲区，不代表数据已经真正通过网络发送或对方已接收</p><ul><li>数据仍可能滞留在发送缓冲区</li><li>如果网络出现拥堵或对方不可达，数据可能延迟或丢失</li><li>TCP 的可靠性体现在协议层的重传和确认机制，应用层仅能确认数据进入内核缓冲区</li></ul><br><br><br><h1 id="网络攻击"><a href="#网络攻击" class="headerlink" title="网络攻击"></a>网络攻击</h1><h2 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h2><p>攻击者通过大量<strong>肉鸡</strong>，向目标服务器发送海量请求，耗尽其带宽、CPU、内存，导致服务器瘫痪，无法为正常用户提供访问</p><p>常见攻击方式</p><ul><li>流量型：UDP 洪水，直接用流量压垮</li><li>协议型：SYN 洪水、Ping of Death，利用协议漏洞让服务器耗尽资源</li><li>应用层攻击：HTTP 请求洪水，高频率模拟正常用户操作</li></ul><p>防护措施</p><ul><li>CDN 或 WAF 缓解压力</li><li>启用速率限制、IP黑名单</li><li>及时识别异常流量模式</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>具有独立的内存空间、代码段、数据段、堆栈等，切换进程开销较大</p><h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><ul><li>socket 套接字</li><li>管道</li><li>信号</li><li>信号量</li><li>消息队列</li><li>共享内存</li></ul><br><br><h2 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h2><br><br><h2 id="进程-API"><a href="#进程-API" class="headerlink" title="进程 API"></a>进程 API</h2><br><br><br><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>同一进程下的线程共享内存空间和资源，只有独立的栈和寄存器，切换线程开销较小</p><h2 id="通信方式-1"><a href="#通信方式-1" class="headerlink" title="通信方式"></a>通信方式</h2><ul><li>锁</li><li>条件变量</li><li>信号量</li><li>事件</li></ul><br><br><h2 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h2><ul><li>互斥锁：同一时间只有一个线程访问共享资源</li><li>自旋锁：自旋等待，适合锁时间短的场景</li><li>条件变量：搭配锁使用，实现线程等待&#x2F;唤醒</li><li>信号量：控制并发资源的访问数量</li></ul><br><br><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>线程安全</p><p>保证线程安全的方式</p><br><br><h2 id="线程-API"><a href="#线程-API" class="headerlink" title="线程 API"></a>线程 API</h2><br><br><p><strong>进程、线程、协程的区别与使用场景</strong></p><p><strong>上下文切换</strong></p><br><br><br><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h2 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h2><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h2><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁&#x2F;非公平锁"></a>公平锁&#x2F;非公平锁</h2><h2 id="无锁"><a href="#无锁" class="headerlink" title="无锁"></a>无锁</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2025/04/27/Redis/"/>
      <url>/2025/04/27/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis-为什么快"><a href="#Redis-为什么快" class="headerlink" title="Redis 为什么快"></a>Redis 为什么快</h1><ul><li><p>内存存储：数据都保存在内存中，访问速度极快</p></li><li><p>单线程架构：单线程<strong>事件循环</strong>模型，避免锁竞争、上下文切换的开销</p></li></ul><p>​<strong>注：持久化机制和集群通信是多线程</strong></p><ul><li><p>高效数据结构：哈希表、压缩列表、跳表等，大多操作时间复杂度都是 O(1) 或 O(logN)</p></li><li><p>零拷贝机制：Redis 在发送响应给客户端时，利用了操作系统的 <strong>writev</strong> 等系统调用，直接将多个缓冲区内容合并输出，<strong>避免不必要的数据拷贝</strong></p></li><li><p>高效 I&#x2F;O 模型：使用 I&#x2F;O 多路复用中的 epoll 模型，高并发场景下的效率最高</p></li><li><p>协议简单：采用<strong>自定义的 RESP 协议</strong>，格式简单、解析快，在客户端与服务器间的<strong>通信开销小</strong></p></li><li><p>异步持久化：持久化交由后台线程，保证主线程的性能</p></li><li><p>集群和分布式支持：可水平扩展读写性能</p></li></ul><br><br><br><h1 id="渐进式-rehash"><a href="#渐进式-rehash" class="headerlink" title="渐进式 rehash"></a>渐进式 rehash</h1><p>Hash 类型底层由两张哈希表 ht[0]、ht[1] 实现</p><ul><li>当 ht[0] 的负载因子 &gt; 1.0 时，触发扩容操作，分配一个更大的新哈希表 ht[1]，设置 rehashidx &#x3D; 0</li><li>增添元素时，会直接插入在 ht[1] 中</li><li>删除元素时，会同时查两张表，然后将其删掉</li><li>修改元素时，会先查 key 在那张表中，然后在对应表中更新，并将其迁移到 ht[1] 中</li><li>查找元素时，由于正在进行数据迁移，需要同时查两张表</li><li>当 ht[0] 的元素都搬到 ht[1] 后，用 ht[1] 替换 ht[0]，设置 rehashidx &#x3D; -1</li></ul><br><p><strong>rehashidx 表示当前进行到第几个槽位，等于 -1 表示未开启 rehash</strong></p><p><strong>按槽位进行迁移，如果一个槽上有多个 key，则将其以链表的形式插入到 ht[1] 中</strong></p><p><strong>Redis 底层的字典结构也是采取渐进式 rehash</strong></p><p>由于Redis 执行命令是单线程的，如果一次性完成 rehash的话，会导致 Redis 无法响应客户端的命令，  所以将其分散到每次对哈希表的增删改查操作中</p><p><strong>为什么 6.0 版本后提出了多线程的概念？</strong></p><p>6.0 之前，主线程 &#x3D; 处理所有客户端请求 + 处理所有命令逻辑 + 处理网络 IO</p><p>如果客户端的网速慢、或数据量大，Redis 主线程会卡在网络 IO 的 read() 或 write() 上，成为性能瓶颈，引入多线程的初衷就是为了加速网络 IO</p><br><br><br><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">由于项目中只用到了 Hash 结构，先对其进行详细记录，其余数据结构后续补充</span><br></pre></td></tr></table></figure><h2 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h2><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><ul><li>如果哈希类型元素小于 512 个，所有值小于 64 字节，以<strong>压缩列表</strong>作为数据结构</li><li>不满足上述条件则以<strong>哈希表</strong>作为数据结构</li></ul><br><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><strong>key, filed, value</strong> 结构与对象的<strong>对象id，属性，值</strong>结构相似</p><br><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li><p>存储一个哈希表 key 的键值</p><p><code>HSET key field value</code></p></li><li><p>获取 key 对应的 value</p><p><code>HGET key field</code></p></li><li><p>删除 key 对应的 field 键值</p><p><code>HDEL key field [field ...]</code></p></li></ul><br><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>缓存对象</strong></p><p>例：<code>HMSET uid:1 name X age 15</code>存储一个哈希表 uid:1 的键值</p><p><strong>购物车</strong></p><br><br><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>int 和 SDS（简单动态字符串）</p><br><h3 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>缓存对象</strong></p><p><strong>常规计数</strong></p><p><strong>分布式锁</strong></p><p>​SET 支持 NX 参数，实现 <strong>key 不存在时才插入</strong></p><p><strong>共享 session</strong></p><br><br><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>双向链表或压缩列表</p><br><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p>FIFO 顺序对数据进行存取操作</p><br><h3 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>消息队列</strong></p><br><br><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a>数据结构</h3><p>哈希表或整数集合</p><br><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>支持取差集、并集和交集操作</p><br><h3 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>点赞</strong></p><p><strong>共同关注</strong></p><br><br><h2 id="Zset"><a href="#Zset" class="headerlink" title="Zset"></a>Zset</h2><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a>数据结构</h3><p>压缩列表或跳表</p><br><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>可以根据元素的权重进行排序</p><br><h3 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h3><p><strong>排行榜</strong></p><br><br><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><h3 id="数据结构-5"><a href="#数据结构-5" class="headerlink" title="数据结构"></a>数据结构</h3><p>string作为底层结构</p><br><h3 id="应用场景-5"><a href="#应用场景-5" class="headerlink" title="应用场景"></a>应用场景</h3><p>适用于<strong>二值状态统计</strong>场景，海量数据下有效节省空间</p><p><strong>签到统计</strong></p><p><strong>判断用户登录态</strong></p><br><br><br><h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>宕机或服务器重启后，恢复 Redis 缓存中的数据</p><p><strong>如何实现？</strong></p><p>当 Redis 写操作执行成功后，将其追加到 AOF 日志中，该文件位于磁盘中，可以实现持久化存储</p><p><strong>读操作是否需要存储？</strong></p><p>不需要，读操作不会改变数据状态，没有记录的必要</p><p><strong>为什么要在写操作执行成功后才追加？</strong></p><ol><li>保证 AOF 中记录的语法都是正确的，避免语法检查这一不必要的开销</li><li>避免当前写操作的执行被阻塞，保证 Redis 性能</li></ol><br><h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><ol><li>将 Redis 命令 追加到 AOF 这一操作，会阻塞主进程执行下一个 Redis 命令</li><li>由于写操作执行成功后才做追加，如果此时服务器挂了，还是会造成数据丢失</li></ol><br><h3 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h3><p>Redis 提供了三种写回硬盘的策略</p><ol><li>Always，每条写操作执行成功后，立即将 AOF 日志写回硬盘</li><li>Everysec，写操作执行成功后，先将其加入 AOF 缓冲区，每隔一秒将缓冲区的内容写回硬盘</li><li>No，写操作执行成功后，将其加入 AOF 缓冲区，由操作系统决定何时写回硬盘</li></ol><p><strong>这三种策略是如何实现的？</strong></p><p>本质上是 fsync() 函数的调用时机不同</p><p>Always 每次写入 AOF 数据后，立即调用 fsync() 函数</p><p>Everysec 创建一个异步任务来调用 fsync() 函数</p><p>No 永不调用 fsync() 函数</p><p><strong>如何选取？</strong></p><p>上述风险中提到的两个点，本质上是互斥的，无法同时兼顾</p><p>具体的写回策略须根据业务需要进行设置，给出参考</p><ol><li>追求高性能，采用 No 策略</li><li>追求高可靠，采用 Always 策略，尽可能减少数据丢失</li><li>追求性能且允许少量数据丢失，采取折中的 Everysec 策略</li></ol><br><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><p>随着执行的写操作命令越来越多，AOF 文件的大小越来越大</p><p>重启 Redis 后，需要读 AOF 文件恢复缓存数据，若 AOF 文件太大，恢复过程就很慢</p><p>重写机制就是为了避免这一情况的出现</p><p><strong>如何实现？</strong></p><p>Redis 以 Key-Value 形式存储数据，对于每个 Key，只保留其最新的 Value，这样即使这个键值对被修改多次，也只会保留最新状态，并在 AOF 文件中用一条命令记录它，降低 AOF 文件大小</p><p><strong>具体过程？</strong></p><p>先创建一个新的 AOF 文件，在其中进行重写，重写成功后再覆盖旧的 AOF 文件</p><p><strong>为什么不直接覆写在旧 AOF 文件？</strong></p><p>先写到新的 AOF 中，失败的话，直接删除这个文件即可，避免因重写失败污染AOF 文件</p><p><strong>何时触发？</strong></p><ol><li><p>AOF 文件当前大小 &gt;&#x3D;  auto-aof-rewrite-min-size（ 默认64MB）</p></li><li><p>AOF 文件当前大小 &gt;&#x3D; M * (1 + auto-aof-rewrite-percentage%)，其中 M 为上次重写后 AOF 文件的大小</p><p>举例：上次重写后 AOF 文件大小为 50MB，百分比设定为100，则当前大小达到 100MB 时触发重写</p></li></ol><br><h3 id="后台重写"><a href="#后台重写" class="headerlink" title="后台重写"></a>后台重写</h3><p>由于此时的 AOF 文件已经很大了，且需要读取所有的键值对，此操作如果在主进程进行，就会阻碍其它命令的操作</p><p><strong>如何进行？</strong></p><p>fork 一个 bgrewriteaof 子进程在后台完成重写</p><p><strong>为什么不用更节省资源的线程？</strong></p><p>多线程之间共享内存，如果修改共享内存中的数据，就要加锁保证线程安全，造成额外开销，降低性能</p><p><strong>子进程如何访问父进程的数据？</strong></p><p>创建子进程时会复制一份父进程的页表，二者可以通过不同的虚拟内存访问相同的物理内存，节约物理内存资源。复制页表的过程会阻塞父进程，页表越大，阻塞时间越长。页表会将物理内存的权限标记为<strong>只读</strong></p><p><strong>写时复制（COW）</strong></p><p>由于物理内存权限被标记为只读，若期间子进程或父进程对该物理内存的数据进行修改，就会触发 Copy On Write 机制</p><p>具体流程为：由于违反系统权限，CPU触发<strong>写保护中断</strong>，操作系统在写保护中断处理函数中进行<strong>物理内存复制</strong>，修改子父进程的<strong>内存读写权限</strong>为可读写，最后再对内存中的数据进行写操作</p><p><strong>COW 机制的作用？</strong></p><p>发生写操作时，才复制物理内存，可以减短复制页表时对主进程的阻塞时长</p><p><strong>如果在重写过程中，主进程修改了已存在的键值对，子父进程的数据一致性如何保证？</strong></p><p>Redis内置了 AOF 重写缓冲区，其在创建 <strong>bgrewriteaof 子进程</strong>后启用。重写期间，Redis 执行完的写操作会被同步写到 <strong>AOF 缓冲区</strong>和 <strong>AOF 重写缓冲区</strong></p><p>重写期间，主进程执行三个工作：</p><ol><li>执行客户端发送到命令</li><li>将执行后的写操作追加到 AOF 缓冲区</li><li>将执行后的写操作追加到 AOF 重写缓冲区</li></ol><p>当子进程完成 AOF 重写后，会发送一个信号给主进程，主进程接收到信号后，调用信号处理函数，此函数的功能</p><ol><li>将 AOF 重写缓冲区的所有内容追加到新的 AOF 文件中，保证新旧 AOF 文件保持的数据库状态一致</li><li>将新的 AOF 文件改名，覆盖旧的 AOF 文件</li></ol><p><strong>阻塞主进程的操作</strong></p><ol><li>创建子进程时的页表复制过程</li><li>写时复制</li><li>调用信号处理函数</li></ol><br><br><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>除 AOF 日志外，Redis还提供了 RDB 快照作为持久化方案</p><p><strong>二者区别</strong></p><ul><li>AOF 文件的内容为操作命令</li><li>RDB 文件的内容为二进制数据</li></ul><p>快照，顾名思义为某一个瞬间的记录。RDB 快照记录的是某一瞬间的内存数据（实际数据）；AOF 文件记录的是命令操作的日志（非实际数据）</p><p>用 RDB 文件恢复数据时，只需将其读入内存中即可；而使用用 AOF 文件时，Redis 会创建一个无网络连接的伪客户端，专门用于执行 AOF 文件中的命令。因此 RDB 恢复效率更高</p><p><strong>如何使用？</strong></p><ul><li>SAVE</li></ul><p>​在主进程中生成 RDB 文件，若写入 RDB 文件的时间过长，会阻塞主进程</p><ul><li>BGSAVE</li></ul><p>​fork 一个子进程生成 RDB 文件，避免阻塞主进程</p><p>Redis 的快照是<strong>全量快照</strong>，会将内存中的所有<strong>数据记录</strong>到磁盘中，因此执行频繁不能太高，否则 Redis   性能会降低，但频率降低，故障时丢失的数据更多（RDB的缺点）</p><p>一般设置为 <strong>5 分钟</strong>保存一次快照，这样最多丢失 5 分钟的数据</p><p><strong>BGSAVE 时能修改数据吗？</strong></p><p>可以，跟 AOF 同样会发生<strong>写时复制</strong>，但不会像 AOF 那样追加修改后的数据</p><br><br><h2 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h2><p>4.0 版本提出，其发生在 <strong>AOF 日志重写过程</strong></p><p>此时 fork 出来的子进程会先将与主线程共享的数据以 <strong>RDB 格式写入 AOF 文件</strong>，主线程在此阶段处理的操作命令会被记录在<strong>重写缓冲区</strong>，缓冲区的增量命令会以 <strong>AOF 格式写入 AOF 文件</strong>，写完后通知主进程将<strong>旧的 AOF 文件</strong>替换为<strong>包含 RDB 格式和 AOF 格式的 AOF 文件</strong></p><p>简而言之，若采用混合持久化，AOF <strong>前半段为 RDB 格式的全量数据</strong>，<strong>后半段为 AOF 格式的增量数据</strong></p><p><strong>有什么好处？</strong></p><p>前半段 RDB 加载速度快，后半段 AOF 记录主进程处理的操作命令，减少丢失的数据量</p><br><br><br><h1 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h1><h2 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h2><p>Least Recently Used，即淘汰<strong>最近最少使用</strong>的数据</p><p><strong>如何实现？</strong></p><p><strong>传统 LRU</strong></p><p>基于链表，链表中的元素按照操作顺序从前往后排列，最新操作的<strong>键</strong>会被移到头部，触发内存淘汰时，删除尾部元素即可</p><p><strong><span style="color:blue">存在问题：</span></strong></p><ul><li>需要引入链表，额外内存开销</li><li>大量数据访问时，引起很多链表移动操作，耗时太久，降低 Redis 性能</li></ul><p><strong>Redis 中是如何实现的？</strong></p><p>在 Redis 的<strong>对象结构体</strong>中加入<strong>记录最后一次访问时间的额外字段</strong></p><p>内存淘汰时，进行<strong>随机采样</strong>淘汰，随机取 5 个值（可调整），淘汰其中最久没有使用的那个</p><p><strong>缓存污染</strong></p><p>应用一次读取了大量数据，但这些数据只被读取这一次，也会将其保存在 Redis 中很长时间</p><br><br><h2 id="LFU"><a href="#LFU" class="headerlink" title="LFU"></a>LFU</h2><p>Least Frequently Used，即淘汰<strong>最不经常使用</strong>数据</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">还没用过LFU，后续补充</span><br></pre></td></tr></table></figure><br><br><br><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">具体复制流程待补充</span><br></pre></td></tr></table></figure><p><strong>主节点</strong>进行读写，发生写操作时自动将其同步给从节点；<strong>从节点</strong>一般只读，并执行主节点同步过来的写操作命令</p><p><strong>主从复制模式</strong></p><ul><li><p><strong><span style="color:blue">全量复制</span></strong></p><p>主从第一次同步时，采用全量复制，此时需要<strong>生成 RDB</strong> 和<strong>传输 RDB</strong>，为避免过多主节点和从节点进行 全量复制，将一部分从节点升级为<strong>经理</strong>，让其也有从节点，进而分担主节点的压力</p><p>同步完成后，主从节点会维持长连接，当主节点接收到写操作命令后，就通过长连接传播给从节点，保证主从节点的数据一致性</p></li><li><p><strong><span style="color:blue">基于长连接的命令传播</span></strong></p></li><li><p><strong><span style="color:blue">增量复制</span></strong></p><p>若主从之间网络断开又恢复正常，就只将断联期间的写操作命令同步给从节点</p></li></ul><p><strong>如何判断节点是否正常工作？</strong></p><p>心跳检测：通过 <strong>ping</strong> 操作，若一半以上的节点去 <strong>ping</strong> 同一个节点，都未收到 <strong>pong</strong> 回应，集群就认为该节点挂了，断开它的连接</p><p><strong>主从模式下，过期 key 如何处理？</strong></p><p>当主节点处理了一个 key 或淘汰算法淘汰了一个 key，主节点就模拟一条 <strong>del 命令</strong>发送个从节点，从节点收到后就执行删除 key 操作</p><p><strong>复制是同步还是异步？</strong></p><p>主节点接收到写命令后，先写到内部缓冲区，然后<strong>异步</strong>发送给从节点</p><br><br><h2 id="哨兵节点"><a href="#哨兵节点" class="headerlink" title="哨兵节点"></a>哨兵节点</h2><p>哨兵用于实现<strong>主从节点故障转移</strong>，其会监测主节点是否存活，如果发现主节点挂了，就选举一个从节点作新的主节点，并将新主节点的信息通知给从节点和客户端</p><p>哨兵一般以集群方式部署，至少需要 3 个哨兵节点，哨兵集群负责<strong>监控、选主、通知</strong></p><br><br><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>对数据进行切片，在每个节点上存储不同的内容，实现 Redis 的<strong>分布式存储</strong>，解决<strong>在线扩容</strong>问题</p><p>即使面对亿级数据，也只需增加 Redis 实例并在集群上进行流量调度即可</p><p>整个 Redis 数据库划分为 16384 个哈希槽，集群中的节点均分这些槽位</p><br><h3 id="为什么设置为-16384-个槽位？"><a href="#为什么设置为-16384-个槽位？" class="headerlink" title="为什么设置为 16384 个槽位？"></a>为什么设置为 16384 个槽位？</h3><p><strong>作者原话</strong></p><p>The reason is:</p><ol><li>Normal heartbeat packets carry the full configuration of a node, that can be replaced in an idempotent way with the old in order to update an old config. This means they contain the slots configuration for a node, in raw form, that uses 2k of space with16k slots, but would use a prohibitive 8k of space using 65k slots.</li><li>At the same time it is unlikely that Redis Cluster would scale to more than 1000 mater nodes because of other design tradeoffs.</li></ol><p>So 16k was in the right range to ensure enough slots per master with a max of 1000 maters, but a small enough number to propagate the slot configuration as a raw bitmap easily. Note that in small clusters the bitmap would be hard to compress because when N is small the bitmap would have slots&#x2F;N bits set that is a large percentage of bits set.</p><p>大致意思为</p><p>1.<strong>集群模式</strong>下，需要通过<strong>心跳包机制</strong>定期广播槽位信息。这些信息以位图的形式存储和传输</p><p>16384 个槽位下，位图大小为 16384 &#x2F; 8 &#x2F; 1024 &#x3D; 2KB</p><p>65536 个槽位下，位图大小为 65536 &#x2F; 8 &#x2F; 1024 &#x3D; 8KB</p><p>心跳包大小增大了 4 倍，相应<strong>网络带宽</strong>和<strong>内存</strong>的消耗也会倍增</p><p>2.Redis 设计时预期的主节点上线为 1000 个，在此规模下，每个主节点负责约 16 个槽位，避免<strong>槽位过于稀疏</strong>的同时保证<strong>数据均衡分布</strong></p><p><strong>那为什么不设置更少一点，比如 8192 个？</strong></p><p>每个槽负责的 key 数量增加，每个节点可分配的槽位减少，槽位迁移时需要移动更多数据</p><br><br><br><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h2><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><p>大量缓存数据在同时过期或者Redis宕机，如果此时有大量用户请求，将同时访问数据库，导致数据库压力突增，可能造成数据库宕机，进而导致系统崩溃</p><p>解决方案：</p><ul><li><p><strong>大量数据同时过期</strong></p><ul><li><p><strong><span style="color:blue">均匀设置过期时间</span></strong></p><p>设置过期时间时加上一个随机数，保证数据不会在同一时间过期</p></li><li><p><strong><span style="color:blue">互斥锁</span></strong></p><p>如果请求访问的数据不在 Redis 中，则加互斥锁，保证同一时间内只有一个请求用于构建缓存，缓存构建完成后，释放锁；未能获取互斥锁的请求，可以等待锁释放后读缓存，也可以直接返回空值或默认值</p><p>互斥锁最好设置<strong>超时时间</strong>，否则加锁的请求如果意外阻塞，就会导致锁不释放且其它请求也拿不到锁，系统出现<strong>无响应现象</strong></p><hr></li><li><p><strong><span style="color:blue">后台更新缓存</span></strong></p><p>后台线程定时更新缓存，保证缓存永久有效</p><ul><li>后台线程频繁检测缓存是否有效，若失效则读数据库更新缓存</li><li>引入 MQ 让其发送消息告知后台更新缓存</li></ul><p>上线前先把数据缓存起来，而非用户访问时才触发缓存构建，此为<strong>缓存预热</strong></p></li></ul></li><li><p><strong>Redis宕机</strong>：</p><ul><li><p><strong><span style="color:blue">服务熔断</span></strong></p><p>启动服务熔断机制，暂停业务层面对缓存的访问，直接<strong>返回错误</strong>，无需访问数据库，降低数据库压力，Redis 恢复后，再允许业务层面访问缓存</p><p>保证数据库正常运行，但业务都无法正常进行</p></li><li><p><strong><span style="color:blue">请求限流机制</span></strong></p><p>允许少量请求到达数据库，剩余请求在入口处就拒绝服务，等 Redis 恢复正常并将<strong>缓存预热</strong>后，再接除限流机制</p></li><li><p><strong><span style="color:blue">高可靠集群</span></strong></p><p>通过<strong>主从节点</strong>方式构建 Redis 集群，当主节点宕机时，从节点切换为主节点，继续提供缓存服务</p></li></ul></li></ul><br><h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h3><p>某个热点数据在缓存中过期了，此时大量请求访问这个数据，导致这些请求都击穿缓存直接访问数据库，可能使数据库过载</p><p>解决方案：</p><ul><li><p><strong>互斥锁</strong></p><p>保证同一时间只有一个业务线程更新缓存，未能获取锁的请求，要么等待锁释放后重新读取缓存，</p><p>要么返回空值或默认值</p></li><li><p><strong>不设置过期时间</strong></p><p>后台异步更新缓存；或在热点数据将过期前，通知线程更新缓存并重设过期时间</p></li></ul><br><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><p>查询一个根本不存在的数据，导致每次查询都要去数据库查询，从而使得缓存形同虚设</p><p>解决方案：</p><ul><li><p>非法请求</p><p>入口处判断请求参数是否合法，若非法直接返回错误</p></li><li><p>缓存空值或默认值</p><p>针对查询的数据，在缓存中设置一个空值或默认值，后续查询就不需要查询数据库</p></li><li><p>使用布隆过滤器</p><p>数据库写入时，用布隆过滤器做标记。当请求到来时，若业务线程确认缓存失效，先通过布隆过滤器判断数据是否存在，不存在就不查数据库</p></li></ul><p><strong>布隆过滤器的工作原理</strong></p><p>核心思想：用<strong>一组位数组</strong> + <strong>多个哈希函数</strong>表示集合</p><p>工作原理：</p><ol><li><strong>初始化</strong><ul><li>创建一个长度为 m 的位数组，所有位初始化位 0</li><li>选择 k 个独立的哈希函数，分别映射输入到[0, m - 1]范围</li></ul></li><li><strong>添加元素 x</strong><ul><li>依次使用 k 个哈希函数处理元素 x，得到 k 个下标值</li><li>将这 k 个位置的 bit 设为 1</li></ul></li><li><strong>查询元素 y 是否存在</strong><ul><li>同样计算出 k 个下标值</li><li>若其中任何一个下标的 bit 为 0，则 y 一定不在集合中**（无假阴性）**</li><li>若对应位都为 1，说明 y 可能在集合中**（假阳性）**</li></ul></li></ol><p><strong>m、k 大小如何确定？</strong></p><p>与误判率有关，具体要参考相关的对数计算公式</p><p><strong>为什么会有假阳性？</strong></p><p>因为按<strong>位</strong>判断</p><p>比如说集合中存在 5，就会导致误判 3 和 1也存在集合内</p><p><strong>假阳性能否解决？</strong></p><p>本质为<strong>哈希冲突</strong>，故只能缓解</p><ol><li>加大位数组 m，牺牲一点空间降低假阳性率</li><li>使用层级布隆过滤器</li></ol><br><br><h2 id="数据库与缓存的一致性如何保证"><a href="#数据库与缓存的一致性如何保证" class="headerlink" title="数据库与缓存的一致性如何保证"></a>数据库与缓存的一致性如何保证</h2><h3 id="旁路缓存策略"><a href="#旁路缓存策略" class="headerlink" title="旁路缓存策略"></a>旁路缓存策略</h3><p>先更新数据库，再删缓存</p><ul><li><strong><span style="color:blue">写策略步骤</span></strong><ul><li>更新数据库数据</li><li>删除缓存中的数据</li></ul></li><li><strong><span style="color:blue">读策略步骤</span></strong><ul><li>如果读取数据命中缓存，则直接返回数据</li><li>未命中，则先从数据库中读取数据，然后将其写入缓存并返回数据</li></ul></li></ul><p><strong>潜在问题</strong></p><ol><li><p><strong><span style="color:blue">短期数据不一致</span></strong></p><p>发生在数据库更新完成但缓存还未删除的这一时间窗口内</p></li><li><p><strong><span style="color:blue">长期数据不一致</span></strong></p><p>缓存删除失败（网络故障、Redis 服务异常），保留旧数据直到下次删除</p><p>解决方案：</p><ul><li>引入自动重试机制</li><li>设置 TTL 兜底</li></ul></li><li><p><strong><span style="color:blue">主从延迟放大</span></strong></p><p>读写分离下，若删除缓存后立即有查询请求，可能因主从同步延迟导致缓存回填旧数据</p><p>解决方案：</p><ul><li>关键数据强制读主节点</li><li>延迟双删，更新数据库后，延迟一定时间（如主从同步时间 + 缓冲）再次删除缓存</li></ul><p><strong>延迟双删</strong></p><p>删除缓存 -&gt; 更新数据库 -&gt; 等待主从同步 -&gt; 再次删除缓存</p></li></ol><p><strong>总结</strong></p><ul><li>对一致性要求高：<strong>延迟双删</strong> + <strong>重试机制</strong> + <strong>强制读主库</strong></li><li>对性能要求高：使用 <strong>TTL</strong> 兜底</li><li>折中：引入 <strong>MQ</strong> 异步处理</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2025/04/27/MySQL/"/>
      <url>/2025/04/27/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h1><h2 id="查询时关键字执行顺序"><a href="#查询时关键字执行顺序" class="headerlink" title="查询时关键字执行顺序"></a><strong>查询时关键字执行顺序</strong></h2><ul><li><p>FROM 找到要查的表，如果有 JOIN 则建立联表</p></li><li><p>WHERE 过滤分组前的数据</p></li><li><p>GROUP BY 进行分组</p></li><li><p>HAVING 过滤分组后的数组</p></li><li><p>SELECT 选择查询的字段</p></li><li><p>DISTINCT 去重</p></li><li><p>ORDER BY 对查询结果作排序</p></li><li><p>LIMIT &#x2F; OFFSET 限制行数</p><p>例：LIMIT 10 OFFSET 20，跳过前 20 行并往后查 10 行</p></li></ul><br><br><h2 id="慢-SQL-调优"><a href="#慢-SQL-调优" class="headerlink" title="慢 SQL 调优"></a>慢 SQL 调优</h2><h3 id="从SQL-语句出发"><a href="#从SQL-语句出发" class="headerlink" title="从SQL 语句出发"></a>从SQL 语句出发</h3><ul><li><p>避免使用 <code>SELECT *</code></p><p>读取表中所有字段，增加磁盘 I&#x2F;O 和内存消耗</p></li><li><p>使用 <strong>JOIN</strong> 而非<strong>子查询</strong></p><p>嵌套查询，时间复杂度为 O(N²)</p></li><li><p>用 <strong>IN</strong> 代替 <strong>!&#x3D;</strong> 或 <strong>&lt;&gt;</strong></p><p>!&#x3D; 或 &lt;&gt; 无法有效利用索引，特别当列允许 <strong>NULL</strong> 时，会遍历所有列</p><p>IN 的列表过长可能导致全表扫描，需结合<strong>索引</strong></p></li><li><p>避免<strong>前导通配符</strong></p><p>LIKE 利用的是 % 前的字段，使用 <strong>LIKE ‘%abc%’</strong> 无法利用索引，改为 <strong>LIKE ‘abc%’</strong></p></li></ul><br><h3 id="从索引出发"><a href="#从索引出发" class="headerlink" title="从索引出发"></a>从索引出发</h3><ul><li><p>避免<strong>过多索引</strong></p><p>每个索引都需要占用磁盘空间，增加写操作。优先为<strong>高频查询字段</strong>建索引</p></li><li><p>使用<strong>覆盖索引</strong>减少<strong>回表</strong></p><p>索引包含查询所需字段，直接从<strong>索引树</strong>返回结果</p></li></ul><br><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><p><strong>EXPLAIN</strong> 分析执行计划</p><ul><li><span style = color:blue>连接类型 <strong>type</strong></span>：ALL 表示全表扫描，index 表示索引扫描，ref 表示索引查找</li><li><span style = color:blue>索引 <strong>key</strong></span>：实际使用的索引</li><li><span style = color:blue>行数 <strong>rows</strong></span>：预估扫描行数</li></ul></li><li><p>合并批量插入</p><p>每条 <strong>INSERT</strong> 都需要多次<strong>事务提交</strong>、<strong>日志写入</strong>、<strong>网络开销</strong></p><p>合并可减少事务开销和磁盘 I&#x2F;O</p></li><li><p>硬件优化</p><ul><li><span style = color:blue>内存</span>：扩大 <strong>Buffer Pool</strong>，减少磁盘 I&#x2F;O</li><li><span style = color:blue>磁盘</span>：使用 <strong>SSD</strong> 替换 <strong>HDD</strong>，提升随机读写速度</li><li><span style = color:blue>CPU</span>：<strong>并行</strong>查询时，多核 CPU 可加速计算</li></ul></li></ul><br><br><h2 id="笛卡尔积问题"><a href="#笛卡尔积问题" class="headerlink" title="笛卡尔积问题"></a>笛卡尔积问题</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>多表查询且无连接条件时返回的结果</p><p>假设有两个集合，A &#x3D; {a, b}, B &#x3D; {1, 2, 3}</p><p>则 A 和 B 的笛卡尔积 &#x3D; {{a, 1}, {a, 2}, {a, 3}, {b, 1}, {b, 2}, {b, 3}}，共 6 条记录</p><p><strong>MySQL 中的例子</strong></p><p>假设有表 1、表 2 两张表，数据量分别为 100 和 1000。现在对这两张表作 JOIN，若未建立查询条件，则需要从数据库中将这 1100 条数据拉取到内存中，在内存中进行100 * 1000次的计算，并对这 10W 条数据全表扫描找到想要的数据</p><br><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ul><li>内存占用高：如果两张表各有 10W 条数据，那么<strong>中间结果集</strong>就有 100 亿条，可能导致 <strong>OOM</strong></li><li>I&#x2F;O 频繁：可能把<strong>中间结果集</strong>写入磁盘的<strong>临时表文件</strong>，造成磁盘频繁读写</li><li>耗时长：若<strong>中间结果集</strong>很大，且无过滤条件，只能<strong>全表扫描</strong></li></ul><br><h3 id="如何避免"><a href="#如何避免" class="headerlink" title="如何避免"></a>如何避免</h3><ul><li>显式指定 JOIN，确保多表查询包含 ON 或 USING</li><li>单表查询、业务耦合</li><li>使用 EXPLAIN 排查，若输出中的 type 列未 ALL 且 rows 极大，很可能发生了笛卡尔积</li></ul><br><br><br><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="SQL-执行流程"><a href="#SQL-执行流程" class="headerlink" title="SQL 执行流程"></a>SQL 执行流程</h2><p>MySQL分为 <strong>Server 层</strong>和<strong>存储引擎层</strong></p><br><br><h3 id="Server-层"><a href="#Server-层" class="headerlink" title="Server 层"></a>Server 层</h3><ul><li>连接器：管理客户端连接、身份认证、权限验证</li><li>查询缓存：缓存 SELECT 查询的完整结果，加速重复查询（命中率太低，<strong>8.0 版本移除</strong>）</li><li>解析器：进行词法分析（识别如 SELECT 的关键字）和语法分析，无误则建立语法树</li><li>预处理器：判断表和字段是否存在，将 ***** 扩展为表上的所有列</li><li>优化器：生成并选择最优执行计划（<strong>全表扫描</strong> OR <strong>索引扫描</strong>）</li><li>执行器：执行查询计划，与存储引擎交互并返回结果给客户端</li></ul><br><br><h3 id="存储引擎层"><a href="#存储引擎层" class="headerlink" title="存储引擎层"></a>存储引擎层</h3><ul><li>InnoDB</li><li>MyISAM</li><li>Memory</li></ul><p>不同存储引擎共用一个 Server 层，5.5之后，InnoDB 作为默认存储引擎。<strong>索引数据结构</strong>就是由存储引擎层实现的，不同存储引擎支持的索引类型不同</p><p><strong>存储引擎对比</strong></p><ol><li><p>事务</p><p>只有 InnoDB 支持 ACID 事务，高并发下的首选</p></li><li><p>锁机制</p><p>InnoDB 支持<strong>行级锁</strong>，粒度小，并发性能高，适合<strong>写操作频繁</strong>场景</p><p>MyISAM 和 Memory 只支持<strong>表级锁</strong></p></li><li><p>索引机制</p><p>InnoDB：<strong>聚簇索引</strong>，主键索引和数据存储在一起</p><p>MyISAM：<strong>非聚簇索引</strong>，索引和数据分开</p><p>Memory：默认为 <strong>Hash 索引</strong>，也可用 <strong>B 树</strong></p></li><li><p>数据存储位置</p><p>InnoDB 和 MyISAM 存储在磁盘中</p><p>Memory 存储在内存中，重启即丢失，适用于<strong>缓存</strong>和<strong>临时表</strong></p></li><li><p>崩溃恢复</p><p>InnoDB：undo log、redo log</p><p>MyISAM：借助 myisamchk 工具</p><p>Memory：直接丢失，无法恢复</p></li></ol><br><br><br><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><p>A：原子性，事务内的操作要么全部成功，要么全部失败回滚。通过 Undo log 实现</p><p>I：隔离性，并发执行时，多个事务之间相互隔离。通过 MVCC 和锁实现</p><p>D：持久性，事务提交之后，数据库的修改永不丢失。通过 Redo log 实现</p><p>C：一致性。通过其它三个特性和应用层逻辑实现</p><p>虽称为四大特性，但并不平级，<strong>AID</strong> 是为了达到 <strong>C</strong> 这一目标的手段</p><br><br><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>RU，读未提交：一个事务还未提交时，其他事务就能看到它做的变更</li><li>RC，读已提交：一个事务提交后，其他事务才能看到它做的变更</li><li>RR，可重复读：一个事务执行过程中，看到的数据都是一致的，InnoDB 默认隔离级别</li><li>Serializable，串行化：对记录加读写锁，当多个事务对同一记录做读写操作时，若发生冲突，则按顺序执行操作</li></ul><p>隔离级别：RU &lt; RC &lt; RR &lt; Serializable</p><p>并发性能：RU &gt; RC &gt; RR &gt; Serializable</p><p><strong>分别是如何实现的？</strong></p><ul><li><p>RU：</p><p>写操作对行加排他锁（X锁），读操作天然为读未提交</p></li><li><p>RC：</p><p>每次查询生成一个 Read View 视图；写操作加 X 锁，事务提交后释放</p></li><li><p>RR：</p><p>事务的首次查询生成 Read View 视图，整个事务期间都使用该视图，保证一致性；写操作加行锁和临键锁（Next-Key Lock）</p></li><li><p>串行化：</p><p>读操作隐式转换为 SELECT … LOCK IN SHARE MODE，加共享锁（S锁），写操作加 X 锁</p></li></ul><p><strong>各自会造成什么问题？</strong></p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th><th align="center">加锁读</th></tr></thead><tbody><tr><td align="center"><strong>RU</strong></td><td align="center">✅</td><td align="center">✅</td><td align="center">✅</td><td align="center"></td></tr><tr><td align="center"><strong>RC</strong></td><td align="center"></td><td align="center">✅</td><td align="center">✅</td><td align="center"></td></tr><tr><td align="center"><strong>RR</strong></td><td align="center"></td><td align="center"></td><td align="center">✅（极少）</td><td align="center"></td></tr><tr><td align="center"><strong>串行化</strong></td><td align="center"></td><td align="center"></td><td align="center"></td><td align="center">✅</td></tr></tbody></table><p>脏读：读到其他事务还未提交的数据</p><p>不可重复读：一个事务内多次查询同一字段，前后数据内容不一致</p><p>幻读：一个事务内多次查询同一字段，前后记录数量不一致</p><p>严重性：脏读 &gt; 不可重复读 &gt; 幻读</p><p><strong>可重复读如何避免幻读？</strong></p><ul><li>快照读：通过 MVCC，保证事务期间的 Read View 视图一致</li><li>当前读：SELECT … FOR UPDATE，通过临键锁阻塞其他事务在此锁范围内插入记录</li></ul><p>无法解决的幻读：</p><p>单纯的快照读或当前读都不会导致幻读现象，交叉使用时才有可能导致幻读</p><ul><li>快照读时：事务A开启后，事务B执行了插入操作，且事务A使用了 UPDATE 进行更新，后续事务A可以读到这条记录，导致幻读</li><li>当前读时：事务开启后，先执行快照读，其他事务进行插入操作，后续执行  SELECT … FOR UPDATE 或 SELECT … IN SHARE MODE，发现前后记录数量不一样，导致幻读</li></ul><p>共享锁、互斥锁兼容性</p><table><thead><tr><th align="center"></th><th align="center">X 锁</th><th align="center">S 锁</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center">✅</td></tr></tbody></table><p><strong>为什么默认隔离级别为 RR，却有很多互联网公司用 RC ？</strong></p><ul><li>当前业务场景下，幻读的影响不大</li><li>提高并发性能</li></ul><p><strong>为什么不采用串行化，避免所有事务问题？</strong></p><p>串行化的并发性能过低</p><br><br><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>特定隔离级别下，读写操作不会相互阻塞</li><li>读取的数据是某一时间点的一致性快照，而非最新数据</li><li>提高数据库在高并发环境下的性能和吞吐量</li></ul><br><h3 id="依赖机制"><a href="#依赖机制" class="headerlink" title="依赖机制"></a>依赖机制</h3><ul><li><p>隐藏字段</p><p>InnoDB 在每行记录中维护两个隐藏字段</p><ul><li><span style = color:blue>trx_id</span>：记录最近一次修改该行的<strong>事务 ID</strong></li><li><span style = color:blue>回滚指针 roll_pointer</span>：指向 undo log 中的旧版本，构建<strong>历史快照</strong></li></ul></li><li><p>undo log</p><p>当事务修改数据时，InnoDB 会将修改前的值记录在 undo log 中，<strong>快照读</strong>下，可以通过回滚指针查看旧版本的数据</p></li></ul><br><h3 id="快照读实现原理"><a href="#快照读实现原理" class="headerlink" title="快照读实现原理"></a>快照读实现原理</h3><p>执行快照读时创建 <strong>Read View 视图</strong></p><h4 id="Read-View-的内容"><a href="#Read-View-的内容" class="headerlink" title="Read View 的内容"></a>Read View 的内容</h4><ul><li>m_ids：创建视图时，<strong>活跃事务</strong>的事务 ID 列表，活跃事务即<strong>启动但未提交事务</strong></li><li>min_trx_id：m_ids 中的<strong>最小事务 ID</strong>，ID 比它小的一定是<strong>已提交事务</strong></li><li>max_trx_id：<strong>全局事务</strong>中最大事务 ID 值 +１</li><li>creator_trx_id：创建该视图的 事务 ID</li></ul><h4 id="MVCC-版本链"><a href="#MVCC-版本链" class="headerlink" title="MVCC 版本链"></a>MVCC 版本链</h4><p>创建视图后，可以将隐藏字段中的 trx_id 划分为三种情况</p><ul><li><strong>已提交事务</strong>：事务 ID 小于 min_trx_id，该版本记录对当前事务<strong>可见</strong></li><li><strong>启动但未提交事务</strong>：事务 ID 在 [min_trx_id, max_trx_id] 区间内，版本记录对当前事务<strong>不可见</strong></li><li><strong>还未开始的事务</strong>：事务 ID 大于 max_trx_id，版本记录对当前事务<strong>不可见</strong></li></ul><p>可通过 roll_pointer 回滚到该链上的旧版本</p><br><br><br><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><p>加快查询数据的速度，相当于<strong>书籍的目录</strong></p><br><br><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="按数据结构分类"><a href="#按数据结构分类" class="headerlink" title="按数据结构分类"></a>按数据结构分类</h3><ul><li><p>B+ 树索引</p><p>多叉平衡树，<strong>叶子节点</strong>存放<strong>数据</strong>，<strong>非叶子节点</strong>只存放<strong>索引</strong>，并且每个节点里的<strong>数据按主键顺序存放</strong>。父节点的索引值都会出现在下层子节点的索引值中，因此叶子节点中包含所有索引值信息。</p><p>除此之外，每个<strong>叶子节点</strong>还有两个指针，分别指向前一个和后一个叶子节点，形成<strong>双向链表</strong>，可用于实现范围查询</p><p><strong>主键索引和二级索引的 B+ 树区别</strong></p><p>主键索引的叶子节点存放<strong>实际数据</strong></p><p>二级索引的叶子节点存放<strong>主键值</strong>，再到主键索引中找到对应的数据（<strong>回表</strong>）</p><p><strong>如何避免回表？</strong></p><p>回表需要查两棵 B+ 树，效率较低。使用<strong>覆盖索引</strong>将查询需要的所有列都包含在二级索引的叶子节点，就无需到主键索引中查找行数据</p></li><li><p>Hash 索引</p><p>基于哈希表实现，无序，只支持等值查询</p></li><li><p>全文索引 Full-Text</p><p>按<strong>关键字分词构建倒排索引</strong>，用于大文本字段的<strong>模糊查找</strong></p></li></ul><p>三者对比</p><table><thead><tr><th align="center"></th><th align="center">B+ 树索引</th><th align="center">Hash 索引</th><th align="center">全文索引</th></tr></thead><tbody><tr><td align="center">底层结构</td><td align="center">B+ 树</td><td align="center">哈希表</td><td align="center">倒排索引</td></tr><tr><td align="center">优势</td><td align="center">范围、有序查询快</td><td align="center">等值查询最快</td><td align="center">适合模糊匹配、大量文本搜索</td></tr><tr><td align="center">劣势</td><td align="center">等值略慢于 Hash</td><td align="center">不支持范围&#x2F;排序查询</td><td align="center">不支持结构化字段、更新开销大</td></tr><tr><td align="center">示例场景</td><td align="center">通用查询，支持排序&#x2F;范围</td><td align="center">用户 ID 精确查找</td><td align="center">文本检索、搜索引擎类功能</td></tr></tbody></table><p><strong>InnoDB 为什么选 B+ 树作默认索引</strong></p><ul><li><p>对比 B 树</p><p>B 树的非叶子节点也存储数据，相较于 B+ 树，其每个节点存储的数据更多，导致单个节点更大，占用<strong>更多磁盘空间</strong>；B+ 树则把所有数据集中存储在叶子节点，非叶节点仅用于导航，节点结构更稳定，单个节点能容纳更多索引项，I&#x2F;O 效率更高</p><p>B+ 树的叶子节点通过链表相连，天然支持范围查询，而 B 树不支持</p></li><li><p>对比二叉树</p><p>B+ 树的搜索复杂度为 O(log<sub>d</sub>N)，其中 d 表示节点允许的最大子节点个数，实际应用中 d 大于 1000，可保证在<strong>千万级数据量</strong>下，仍然可以维持 3<del>4 的层高，即一次查询只需要 3</del>4 次磁盘 I&#x2F;O 就可找到  目标数据</p><p>二叉树的子节点个数固定为 2，搜索复杂度为 O(logN)，比 B+ 树高不少，查询时需要更多的磁盘 I&#x2F;O</p></li><li><p>对比 Hash</p><p>虽然 Hash 的搜索复杂度为 O(1)，比 B+ 树快，但其只适用于<strong>等值查询</strong>而非<strong>范围查询</strong></p></li></ul><br><h3 id="按物理存储分类"><a href="#按物理存储分类" class="headerlink" title="按物理存储分类"></a>按物理存储分类</h3><ul><li><p>聚簇索引（主键索引）</p><p>叶子节点存放实际数据，完整的用户记录都存放在主键索引的 B+ 树叶子节点中</p><p><strong>叶子节点存多少数据？</strong></p><p>叶子节点相当于数据页，故每个叶子节点存储若干行数据</p><p><strong>向叶子节点插入一条数据的过程？</strong></p><p>从根节点开始，比较索引键，找到适合的叶子节点，查找复杂度为 O(logN)</p><p>如果叶子节点有足够空间，则直接插入</p><p>没有则发生<strong>页分裂</strong>，将数据<strong>对半分裂</strong>，一部分记录移到新页，此时要更新父节点的指针，使其指向这两个页</p></li><li><p>非聚簇索引（二级索引、辅助索引）</p><p>叶子节点存放主键而非实际数据</p></li></ul><br><h3 id="按字段特性分类"><a href="#按字段特性分类" class="headerlink" title="按字段特性分类"></a>按字段特性分类</h3><ul><li><p>主键索引</p><p>每表最多一个，列的值不允许有空值</p></li><li><p>唯一索引</p><p>可以多个，索引列的值必须唯一，允许空值（多个 NULL 不会触发唯一性冲突）</p></li><li><p>普通索引</p></li><li><p>前缀索引</p><p>只为字符类型字段的前几个字符建立索引，减少索引占用的存储空间，提高查询效率</p></li></ul><br><h3 id="按字段个数分类"><a href="#按字段个数分类" class="headerlink" title="按字段个数分类"></a>按字段个数分类</h3><ul><li><p>单列索引</p><p>建立在单列上，如主键索引</p></li><li><p>联合索引（复合索引）</p><p>假设存在字段 name 和 age，(name, age) 即为二者组成的联合索引</p></li></ul><p><strong>联合索引如何实现？</strong></p><p>非叶子节点用两个字段的值作为 B+ 树的 key。当联合索引在查询数据时，先按 name 字段比较，name 相同情况下再比较 age 字段，存在<strong>最左匹配原则</strong>，即按照最左优先的方式进行索引匹配，若不遵循，会导致索引失效，转为<strong>全表扫描</strong></p><p>例：联合索引 (a, b, c)，下列查询条件可以匹配联合索引</p><ul><li>where a &#x3D; 1;</li><li>where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</li><li>where a &#x3D; 1 and b &#x3D; 2;</li></ul><p>由于<strong>优化器</strong>的存在，所以 a 字段在 where 子句中的<strong>顺序不重要</strong></p><p>即使写作 where b &#x3D; 2 and c &#x3D; 3 and a &#x3D; 1; 仍会被重排为 where a &#x3D; 1 and b &#x3D; 2 and c &#x3D; 3;</p><p>但如果没有 a 字段，就会失效</p><br><p>where a &gt; 1 and b &#x3D; 2 and c &#x3D; 3;</p><p>只能用到索引 a，因为执行 a &gt; 1 索引扫描会从 a &#x3D; 2 开始顺序扫描，此时 b 是乱序的，MySQL 并不确定 b &#x3D; 2 是否还排序在一起，触发<strong>索引截断</strong></p><p><strong>当只有最后一个字段使用范围查询时，才不会索引截断</strong></p><br><br><h2 id="什么时候需要创建索引"><a href="#什么时候需要创建索引" class="headerlink" title="什么时候需要创建索引"></a>什么时候需要创建索引</h2><ul><li><p>频繁作为 WHERE 查询条件的字段</p><p>显著减少扫描的行数</p></li><li><p>用于 ORDER BY 和 GROUP BY 的字段</p><p>按<strong>索引顺序直接输出</strong>，避免排序操作（因为 B+ 树是有序结构，按索引顺序输出即可保证有序）</p></li><li><p>用于 JOIN 条件的字段</p><p><strong>外键字段</strong>可以加速关联查询</p></li><li><p>用于覆盖索引的字段</p><p>查询可以只从索引返回，无需回表</p></li><li><p>高基数字段</p><p><strong>基数高 &#x3D; 唯一值多</strong>（用户ID、手机号），适合建索引</p><p>索引的选择性高，扫描的数据页更少</p></li></ul><br><br><h2 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h2><ul><li><p><strong>不遵循最左匹配原则</strong></p><p>B+ 树查找是需要<strong>从左往右</strong>匹配字段，不遵循最左匹配原则就会退化为全表扫描</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 有联合索引： (a, b, c)</span><br><span class="line">SELECT * FROM table WHERE b = 1;</span><br><span class="line"></span><br><span class="line"># b 没有 a 的值，无法进入对应范围，只能全表扫描</span><br><span class="line"># 正确写法</span><br><span class="line">SELECT * FROM table WHERE a = 1 AND b = 1;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用左或左右模糊匹配</strong></p><p>% 开头意味着以<strong>任意字符开头</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE name LIKE &#x27;%abc&#x27;</span><br><span class="line"></span><br><span class="line"># 正确写法</span><br><span class="line">SELECT * FROM users WHERE name LIKE &#x27;abc%&#x27;;</span><br></pre></td></tr></table></figure></li><li><p><strong>WHERE 子句中使用 OR</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13812345678&#x27;</span> <span class="keyword">OR</span> email <span class="operator">=</span> <span class="string">&#x27;abc@example.com&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 假设 phone 和 eamil 都有索引，MySQL 无法同时使用两个索引，会改为全表扫描</span><br><span class="line"># 改为下面这种写法</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone <span class="operator">=</span> <span class="string">&#x27;13812345678&#x27;</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> eamil <span class="operator">=</span> <span class="string">&#x27;abc@example.com&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>对索引使用函数</strong></p><p>MySQL 无法直接利用索引，只能逐行计算函数值进行比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM users WHERE LEFT(phone, 3) = &#x27;138&#x27;;</span><br><span class="line"></span><br><span class="line"># 正确写法</span><br><span class="line">SELECT * FROM users WHERE phone LIKE &#x27;138%&#x27;;  -- 能用索引</span><br></pre></td></tr></table></figure></li><li><p><strong>对索引做表达式计算</strong></p><p>该变了字段原本的值，而 B+ 树上存储的是原始值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM orders WHERE price + 10 &gt; 100;</span><br><span class="line"></span><br><span class="line"># 正确写法</span><br><span class="line">SELECT * FROM orders WHERE price &gt; 90;  -- 可以用索引</span><br></pre></td></tr></table></figure></li></ul><br><br><h2 id="多少层的-B-树能存下-2000W-行数据"><a href="#多少层的-B-树能存下-2000W-行数据" class="headerlink" title="多少层的 B+ 树能存下 2000W 行数据"></a>多少层的 B+ 树能存下 2000W 行数据</h2><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><ul><li><p>页大小：<strong>16KB &#x3D; 16 × 1024 &#x3D; 16,384 字节</strong></p></li><li><p>假设每条索引项（键+指针）占：<strong>16 字节</strong></p><ul><li>键：8 字节</li><li>指针：8 字节</li></ul></li><li><p>每个内部节点（非叶子节点）可容纳的键数：</p></li></ul><p>​16,384 &#x2F; 16 ≈ 1024 个键（→ 1025 个子节点）</p><ul><li><p>假设一条记录平均占用：<strong>128 字节</strong></p></li><li><p>每个叶子节点能容纳的记录数：16384 &#x2F; 128 &#x3D; 128 条</p></li></ul><br><h3 id="推导层级结构"><a href="#推导层级结构" class="headerlink" title="推导层级结构"></a>推导层级结构</h3><p><strong>第1层：叶子节点</strong></p><ul><li>总数据量：20,000,000 行</li><li>每页记录数：128</li><li>需要的叶子页数：20,000,000 &#x2F; 128 ≈ 156,250 页（即叶子节点）</li></ul><p><strong>第2层：第一层中间节点（指向叶子节点）</strong></p><ul><li>一个中间节点可容纳指针数 ≈ <strong>1025</strong></li><li>页数：156,250 &#x2F; 1025 ≈ 153 页</li></ul><p><strong>第3层：第二层中间节点（指向上一层）</strong></p><ul><li>153 &#x2F; 1025 ≈ <strong>0.15</strong>，只需要 1 个节点（根节点）</li></ul><p>所以<strong>总共需要 3 层</strong></p><br><br><br><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="锁类型"><a href="#锁类型" class="headerlink" title="锁类型"></a>锁类型</h2><h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>在 MyISAM 中使用，加上之后整个表都是只读状态，用于备份数据库</p><br><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><ul><li><p>表锁</p><p>限制其他线程对该表的写入，但本线程也无法访问其他表</p></li><li><p>意向锁</p><p>用来判断表中是否有记录被加锁</p><p>InnoDB 下，加<strong>共享锁</strong>先前，要现在表级别上加一个<strong>意向共享锁</strong></p><p>InnoDB 下，加<strong>独占锁</strong>先前，要现在表级别上加一个<strong>意向独占锁</strong></p><p>也就是说，当执行插入、更新、删除操作时需要先对表加<strong>意向独占锁</strong></p></li></ul><p>表锁粒度大，InnoDB下一般不用，因为对并发性能影响大</p><br><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><ul><li><p>记录锁</p><p>锁住的是一条记录，有 S 锁和 X 锁之分</p></li><li><p>间隙锁</p><p>锁住的是一个范围，可兼容，两个事务可<strong>同时持有</strong>包含<strong>相同间隙范围的间隙锁</strong></p></li><li><p>临键锁</p><p>同时锁住记录和间隙范围，有 S 和 X 之分</p></li><li><p>插入意向锁</p><p>事务在插入记录时，先判断插入位置是否已被其他事务加间隙锁。如果有，那么插入操作会阻塞并生成一个插入意向锁，表示有事务想在某个区间内插入记录</p><p><strong>特殊的间隙锁，锁的是一个点</strong></p></li></ul><p><strong>MySQL 为什么要设计这么多锁？</strong></p><ol><li>平衡性能与开销</li><li>防止并发事务下的问题</li><li>适配不同存储引擎</li></ol><br><br><h2 id="MySQL-死锁"><a href="#MySQL-死锁" class="headerlink" title="MySQL 死锁"></a>MySQL 死锁</h2><h3 id="如何产生"><a href="#如何产生" class="headerlink" title="如何产生"></a>如何产生</h3><h4 id="必备的四个条件"><a href="#必备的四个条件" class="headerlink" title="必备的四个条件"></a>必备的四个条件</h4><ul><li><strong>互斥条件</strong>：某些资源一次只能被一个事务占用</li><li><strong>请求与保持条件</strong>：一个事务已经获得了某个资源，在等待另一个资源时不会释放自己已占有的资源</li><li><strong>不剥夺条件</strong>：事务获取到的资源，在使用完之前，系统不能强制剥夺</li><li><strong>循环等待条件</strong>：存在一个事务等待链，链中的每一个事务都在等待下一个事务所持有的资源</li></ul><h4 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h4><p>不同顺序访问同一组表或行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-- 事务1</span><br><span class="line">UPDATE A WHERE id=1;</span><br><span class="line">UPDATE B WHERE id=1;</span><br><span class="line"></span><br><span class="line">-- 事务2</span><br><span class="line">UPDATE B WHERE id=1;</span><br><span class="line">UPDATE A WHERE id=1;</span><br></pre></td></tr></table></figure><p>若事务 1 先锁表 A，事务 2 先锁表 B，就会进入相互等待的死锁状态</p><br><h3 id="如何避免-1"><a href="#如何避免-1" class="headerlink" title="如何避免"></a>如何避免</h3><ul><li>始终按照相同的顺序访问资源</li><li>尽量缩短事务执行时间，减少持锁时间</li></ul><br><br><br><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层实现待补充</span><br></pre></td></tr></table></figure><h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><ul><li><p>保证事务的原子性</p><p>事务处理过程中<strong>出现错误</strong>或<strong>执行 ROLLBACK 语句</strong>，将利用 undo log 中的历史数据回滚版本</p></li><li><p>实现 MVCC 的关键因素</p><p>Read View + undo log 构成版本链，实现多版本并发控制</p></li></ul><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>存储结构：撤销段</p><br><br><h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><p>当对数据页的修改提交后，都要先写入 redo log，最后以<strong>脏页形式</strong>刷盘，称作<span style=color:blue>Write-Ahead Logging技术</span></p><h3 id="为什么-redo-log-和数据都要写入磁盘"><a href="#为什么-redo-log-和数据都要写入磁盘" class="headerlink" title="为什么 redo log 和数据都要写入磁盘"></a>为什么 redo log 和数据都要写入磁盘</h3><ul><li><p>写入方式</p><p>写入 redo log 为追加操作，故磁盘操作为顺序写</p><p>写入数据需要先找到写入位置，故磁盘操作为随机写</p><p>顺序写的效率更高，提高 MySQL 的写入性能</p></li><li><p>保证事务的持久性</p><p>MySQL 崩溃时，通过 redo log 可以保证之前提交的记录不丢失</p></li></ul><br><h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><ul><li>log buffer：内存中，暂存 redo log 的写入</li><li>redo log files：磁盘中，物理日志文件</li></ul><br><br><h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p>Server 层实现的日志，所有存储引擎都可用，记录了<strong>所有数据库表结构变更</strong>和<strong>表数据修改</strong></p><p>追加写，如果写满文件，就新建一个文件继续写，不会覆盖以前的日志，全量保存日志</p><br><br><br><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">底层实现待补充</span><br></pre></td></tr></table></figure><h2 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h2><p>InnoDB 下的一片<strong>连续内存空间</strong>的<strong>缓冲池</strong>，用来缓存<strong>数据页</strong>和<strong>索引页</strong>，减少磁盘 I&#x2F;O</p><p>默认大小为 128MB，可通过 innodb_buffer_pool_size 进行设置，建议为可用物理内存的 60~80%</p><p><strong>怎么缓冲？</strong></p><p>查询一条记录时，将这条记录所在页都缓冲到 buffer pool 中</p><br><br><h2 id="如何管理"><a href="#如何管理" class="headerlink" title="如何管理"></a>如何管理</h2><h3 id="管理空闲页"><a href="#管理空闲页" class="headerlink" title="管理空闲页"></a>管理空闲页</h3><p><strong>Free List</strong></p><p>通过 Free 链表来记录控制块，以及一个头节点，头节点包含链表头节点地址、尾节点地址，以及当前链表中节点的数据等信息</p><br><h3 id="管理脏页"><a href="#管理脏页" class="headerlink" title="管理脏页"></a>管理脏页</h3><p><strong>Flush List</strong></p><p>更新数据时并非每次都刷盘，而是先将对应页标记为<strong>脏页</strong>，再由后台线程将其写入到磁盘中</p><p><strong>什么时候将脏页刷盘</strong></p><ul><li>redo log 满了，自动触发脏页刷新到磁盘</li><li>Buffer Pool 空间不足，需将一部分数据页淘汰掉，若数据页为<strong>脏页</strong>，则将其刷盘</li><li>MySQL 空闲时</li><li>MySQL 正常关闭前</li></ul><p><strong>如果宕机了，脏页数据会不会丢？</strong></p><p>不会，InnoDB 采用 <strong>WAL 预写日志</strong>机制，数据修改之前会先<strong>将修改操作</strong>写入 redo log，可通过它恢复</p><br><h3 id="如何提高缓存命中率"><a href="#如何提高缓存命中率" class="headerlink" title="如何提高缓存命中率"></a>如何提高缓存命中率</h3><p><strong>LRU List</strong></p><p>管理脏页 + 干净页，将最近经常查询的数据缓存，不常查询的就淘汰</p><p><strong>InnoDB 对 LRU 的优化</strong></p><ul><li>将其分为 young 和 old 两个区域，加入缓冲池的页，优先插入到 old 区域；页被访问时，才进入 young 区域，用于解决<strong>预读失效问题</strong></li><li>当页被访问或 old 区域停留时间超过阈值，将页插入到 young 区域，否则还是插入到 old 区，解决  <strong>批量数据访问，大量热数据淘汰问题</strong></li></ul><br><br><br><h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
