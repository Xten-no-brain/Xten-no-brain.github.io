<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络</title>
      <link href="/2025/04/27/%E7%BD%91%E7%BB%9C/"/>
      <url>/2025/04/27/%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h1><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2025/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2025/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h1 id="系统内核"><a href="#系统内核" class="headerlink" title="系统内核"></a>系统内核</h1><h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h1 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h1><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h1 id="网络系统"><a href="#网络系统" class="headerlink" title="网络系统"></a>网络系统</h1><h1 id="Linux命令"><a href="#Linux命令" class="headerlink" title="Linux命令"></a>Linux命令</h1>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2025/04/27/Redis/"/>
      <url>/2025/04/27/Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h1 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制"></a>持久化机制</h1><h2 id="AOF日志"><a href="#AOF日志" class="headerlink" title="AOF日志"></a>AOF日志</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>宕机或服务器重启后，恢复 Redis 缓存中的数据</p><p><strong>如何实现？</strong></p><p>当 Redis 写操作执行成功后，将其追加到 AOF 日志中，该文件位于磁盘中，可以实现持久化存储</p><p><strong>读操作是否需要存储？</strong></p><p>不需要，读操作不会改变数据状态，没有记录的必要</p><p><strong>为什么要在写操作执行成功后才追加？</strong></p><ol><li>保证 AOF 中记录的语法都是正确的，避免语法检查这一不必要的开销</li><li>避免当前写操作的执行被阻塞，保证 Redis 性能</li></ol><h3 id="潜在风险"><a href="#潜在风险" class="headerlink" title="潜在风险"></a>潜在风险</h3><ol><li>将 Redis 命令 追加到 AOF 这一操作，会阻塞主进程执行下一个 Redis 命令</li><li>由于写操作执行成功后才做追加，如果此时服务器挂了，还是会造成数据丢失</li></ol><h3 id="写回策略"><a href="#写回策略" class="headerlink" title="写回策略"></a>写回策略</h3><p>Redis 提供了三种写回硬盘的策略</p><ol><li>Always，每条写操作执行成功后，立即将 AOF 日志写回硬盘</li><li>Everysec，写操作执行成功后，先将其加入 AOF 缓冲区，每隔一秒将缓冲区的内容写回硬盘</li><li>No，写操作执行成功后，将其加入 AOF 缓冲区，由操作系统决定何时写回硬盘</li></ol><p><strong>这三种策略是如何实现的？</strong></p><p>本质上是 fsync() 函数的调用时机不同</p><p>Always 每次写入 AOF 数据后，立即调用 fsync() 函数</p><p>Everysec 创建一个异步任务来调用 fsync() 函数</p><p>No 永不调用 fsync() 函数</p><p><strong>如何选取？</strong></p><p>上述风险中提到的两个点，本质上是互斥的，无法同时兼顾</p><p>具体的写回策略须根据业务需要进行设置，给出参考</p><ol><li>追求高性能，采用 No 策略</li><li>追求高可靠，采用 Always 策略，尽可能减少数据丢失</li><li>追求性能且允许少量数据丢失，采取折中的 Everysec 策略</li></ol><h3 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h3><p>随着执行的写操作命令越来越多，AOF 文件的大小越来越大</p><p>重启 Redis 后，需要读 AOF 文件恢复缓存数据，若 AOF 文件太大，恢复过程就很慢</p><p>重写机制就是为了避免这一情况的出现</p><p><strong>如何实现？</strong></p><p>Redis 以 Key-Value 形式存储数据，对于每个 Key，只保留其最新的 Value，这样即使这个键值对被修改多次，也只会保留最新状态，并在 AOF 文件中用一条命令记录它，降低 AOF 文件大小</p><p><strong>具体过程？</strong></p><p>先创建一个新的 AOF 文件，在其中进行重写，重写成功后再覆盖旧的 AOF 文件</p><p><strong>为什么不直接覆写在旧 AOF 文件？</strong></p><p>先写到新的 AOF 中，失败的话，直接删除这个文件即可，避免因重写失败污染AOF 文件</p><p><strong>何时触发？</strong></p><ol><li><p>AOF 文件当前大小 &gt;&#x3D;  auto-aof-rewrite-min-size（ 默认64MB）</p></li><li><p>AOF 文件当前大小 &gt;&#x3D; M * (1 + auto-aof-rewrite-percentage%)，其中 M 为上次重写后 AOF 文件的大小</p><p>举例：上次重写后 AOF 文件大小为 50MB，百分比设定为100，则当前大小达到 100MB 时触发重写</p></li></ol><h3 id="后台重写"><a href="#后台重写" class="headerlink" title="后台重写"></a>后台重写</h3><p>由于此时的 AOF 文件已经很大了，且需要读取所有的键值对，此操作如果在主进程进行，就会阻碍其它命令的操作</p><p><strong>如何进行？</strong></p><p>fork 一个 bgrewriteaof 子进程在后台完成重写</p><p><strong>为什么不用更节省资源的线程？</strong></p><p>多线程之间共享内存，如果修改共享内存中的数据，就要加锁保证线程安全，造成额外开销，降低性能</p><p><strong>子进程如何访问父进程的数据？</strong></p><p>创建子进程时会复制一份父进程的页表，使得二者可以通过不同的虚拟内存访问相同的物理内存，节约物理内存资源。复制页表的过程会阻塞父进程，页表越大，阻塞时间越长。页表会将物理内存的权限标记为<strong>只读</strong></p><p><strong>写时复制（COW）</strong></p><p>由于物理内存权限被标记为只读，若期间子进程或父进程对该物理内存的数据进行修改，就会触发 Copy On Write 机制</p><p>具体流程为：由于违反系统权限，CPU触发<strong>写保护中断</strong>，操作系统在写保护中断处理函数中进行<strong>物理内存复制</strong>，修改子父进程的<strong>内存读写权限</strong>为可读写，最后再对内存中的数据进行写操作</p><p><strong>COW 机制的作用？</strong></p><p>发生写操作时，才复制物理内存，可以减短复制页表时对主进程的阻塞时长</p><p><strong>如果在重写过程中，主进程修改了已存在的键值对，子父进程的数据一致性如何保证？</strong></p><p>Redis内置了 AOF 重写缓冲区，其在创建 bgrewriteaof 子进程后启用。重写期间，Redis 执行完的写操作会被同步写到 AOF 缓冲区和 AOF 重写缓冲区</p><p>重写期间，主进程执行三个工作：</p><ol><li>执行客户端发送到命令</li><li>将执行后的写操作追加到 AOF 缓冲区</li><li>将执行后的写操作追加到 AOF 重写缓冲区</li></ol><p>当子进程完成 AOF 重写后，会发送一个信号给主进程，主进程接收到信号后，调用信号处理函数，此函数的功能</p><ol><li>将 AOF 重写缓冲区的所有内容追加到新的 AOF 文件中，保证新旧 AOF 文件保持的数据库状态一致</li><li>将新的 AOF 文件改名，覆盖旧的 AOF 文件</li></ol><p><strong>阻塞主进程的操作</strong></p><ol><li>创建子进程时的页表复制过程</li><li>写时复制</li><li>调用信号处理函数</li></ol><h2 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h2><p>除 AOF 日志外，Redis还提供了 RDB 快照作为持久化方案</p><p><strong>二者区别</strong></p><ul><li>AOF 文件的内容为操作命令</li><li>RDB 文件的内容为二进制数据</li></ul><p>快照，顾名思义为某一个瞬间的记录。RDB 快照记录的是某一瞬间的内存数据（实际数据）；AOF 文件记录的是命令操作的日志（非实际数据）</p><p><strong>RDB 恢复数据的效率更高</strong></p><p>用 RDB 文件恢复数据时，只需将其读入内存中即可；而使用用 AOF 文件时，Redis 会创建一个无网络连接的伪客户端，专门用于执行 AOF 文件中的命令</p><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h1 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h1><h2 id="缓存三兄弟"><a href="#缓存三兄弟" class="headerlink" title="缓存三兄弟"></a>缓存三兄弟</h2><h3 id="雪崩"><a href="#雪崩" class="headerlink" title="雪崩"></a>雪崩</h3><h3 id="击穿"><a href="#击穿" class="headerlink" title="击穿"></a>击穿</h3><h3 id="穿透"><a href="#穿透" class="headerlink" title="穿透"></a>穿透</h3><h2 id="数据库与缓存的一致性问题"><a href="#数据库与缓存的一致性问题" class="headerlink" title="数据库与缓存的一致性问题"></a>数据库与缓存的一致性问题</h2>]]></content>
      
      
      <categories>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发组件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2025/04/27/MySQL/"/>
      <url>/2025/04/27/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><p>MySQL分为 <strong>Server 层</strong>和<strong>存储引擎层</strong></p><p><strong>Server 层</strong>包含连接器、查询缓存、解析器、预处理器、优化器、执行器</p><p><strong>存储引擎层</strong>包含 InnoDB、MyISAM 等存储引擎以及数据</p><h2 id="SQL执行流程"><a href="#SQL执行流程" class="headerlink" title="SQL执行流程"></a>SQL执行流程</h2><p>从连接器开始，基于TCP协议确定客户端是否连接成功。连接成功后，当服务端收到客户端的 SQL 语句后，先以<strong>Key-Value</strong>形式到查询缓存里查看是否有这条SQL语句，如果有，则直接返回相应的 Value，即查询结果。若没有，则</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="ACID四大特性"><a href="#ACID四大特性" class="headerlink" title="ACID四大特性"></a>ACID四大特性</h2><p>A：atomicity，原子性。通过 Undo log 实现</p><p>C：consistency，一致性。通过其它三个特性和应用层逻辑实现</p><p>I：isolation，隔离性。通过 MVCC 和锁实现</p><p>D：durability，持久性。通过 Redo log 实现</p><p>虽称为四大特性，但并不平级，<strong>AID</strong> 是为了达到 <strong>C</strong> 这一目标的手段</p><h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><ul><li>RU，读未提交：一个事务还未提交时，其他事务就能看到它做的变更</li><li>RC，读已提交：一个事务提交后，其他事务才能看到它做的变更</li><li>RR，可重复读：一个事务执行过程中，看到的数据都是一致的，InnoDB 默认隔离级别</li><li>Serializable，串行化：对记录加读写锁，当多个事务对同一记录做读写操作时，若发生冲突，则按顺序执行操作</li></ul><p>隔离级别：RU &lt; RC &lt; RR &lt; Serializable</p><p>并发性能：RU &gt; RC &gt; RR &gt; Serializable</p><p><strong>分别是如何实现的？</strong></p><ul><li>RU：直接读取最新数据，包括其它数据未提交的修改；写操作对行加排他锁（X锁），读操作不加锁</li><li>RC：每次查询生成一个 Read View 视图；写操作加 X 锁，事务提交后释放</li><li>RR：事务的首次查询生成 Read View 视图，整个事务期间都使用该视图，保证一致性；写操作加行锁和临键锁（Next-Key Lock）</li><li>串行化：读操作隐式转换为 SELECT … LOCK IN SHARE MODE，加共享锁（S锁），写操作加 X 锁</li></ul><p><strong>各自会造成什么问题？</strong></p><table><thead><tr><th align="center">读未提交</th><th align="center">读已提交</th><th align="center">可重复读</th><th align="center">串行化</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">不可重复读</td><td align="center">不可重复读</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">幻读</td><td align="center">幻读</td><td align="center">极少的幻读</td><td align="center"></td></tr></tbody></table><p>脏读：读到其他事务还未提交的数据</p><p>不可重复读：一个事务内多次查询同一字段，前后数据内容不一致</p><p>幻读：一个事务内多次查询同一字段，前后记录数量不一致</p><p>严重性：脏读 &gt; 不可重复读 &gt; 幻读</p><p><strong>可重复读如何避免幻读？</strong></p><ul><li>快照读：通过 MVCC，保证事务期间的 Read View 视图一致</li><li>当前读：SELECT … FOR UPDATE，通过临键锁阻塞其他事务在此锁范围内插入记录</li></ul><p>无法解决的幻读：</p><p>单纯的快照读或当前读都不会导致幻读现象，交叉使用时才有可能导致幻读</p><ul><li>快照读时：事务A开启后，事务B执行了插入操作，且事务A使用了 UPDATE 进行更新，后续事务A可以读到这条记录，导致幻读</li><li>当前读时：事务开启后，先执行快照读，其他事务进行插入操作，后续执行  SELECT … FOR UPDATE 或 SELECT … IN SHARE MODE，发现前后记录数量不一样，导致幻读</li></ul><p>共享锁、互斥锁兼容性</p><table><thead><tr><th align="center"></th><th align="center">X 锁</th><th align="center">S 锁</th></tr></thead><tbody><tr><td align="center">X</td><td align="center">❌</td><td align="center">❌</td></tr><tr><td align="center">S</td><td align="center">❌</td><td align="center">✅</td></tr></tbody></table><p><strong>为什么默认隔离级别为 RR，阿里却用 RC ？</strong></p><ul><li>当前业务场景下，幻读的影响不大</li><li>提高并发性能</li></ul><p><strong>为什么不采用串行化，避免所有事务问题？</strong></p><p>串行化的并发性能过低</p><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>多版本并发控制</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发组件 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
